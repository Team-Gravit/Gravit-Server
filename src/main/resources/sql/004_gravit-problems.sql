-- Chapter 1
-- Unit01 - 배열 (Lesson ID: 1)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (1, 'FILL_BLANK', '일반적으로 배열은 _____ 종류의 데이터들이 순차적으로 저장되어 있는 자료구조를 의미한다.', '같은, 동일한, 일치하는', '-', 1),

    (2, 'FILL_BLANK', '배열은 선언 시점에 크기가 _____되며, 런타임에 크기를 변경할 수 없다.', '고정, 결정', '-', 1),

    (3, 'FILL_BLANK', '배열은 메모리 상에서 _____적인 위치에 저장하는 자료구조이다.', '연속', '-', 1),

    (4, 'FILL_BLANK', '배열은 연속된 메모리에 저장되기 때문에, 할당받은 공간을 사용하지 않으면 메모리 _____가 발생한다.', '낭비, 누수', '-', 1),

    (5, 'FILL_BLANK', '배열의 _____를 이용해서 값에 접근할 수 있다.', '인덱스', '-', 1),

    (6, 'SELECT_DESCRIPTION', '배열의 첫 번째 요소 인덱스는?', '3', '1.null;2.-1;3.0;4.1', 1),

    (7, 'SELECT_DESCRIPTION', '배열의 인덱스 범위를 벗어난 접근을 시도할 때 발생하는 에러는?', '2', '1.언더플로우;2.오버플로우;3.타입 에러;4.널포인터 에러', 1),

    (8, 'SELECT_DESCRIPTION', '2차원 배열 temp[i][j] 에서 i와 j가 나타내는 의미는?', '1', '1.행과 열;2.열과 행;3.인덱스와 값;4.값과 인덱스', 1),

    (9, 'SELECT_DESCRIPTION', '2차원 배열 temp[i][j] 에서 사용하는 기본 메모리 주소 계산 방식은?', '1', '1.행 우선;2.열 우선;3.대각선 우선;4.임의 순서', 1),

    (10, 'SELECT_DESCRIPTION', '배열에서 인덱스를 이용한 특정 요소 접근의 시간복잡도는?', '1', '1.O(1);2.O(log n);3.O(n);4.O(n²)', 1),

    (11, 'SELECT_DESCRIPTION', '정렬되지 않은 배열에서 특정 요소를 찾는 선형 탐색의 시간복잡도는?', '3', '1.O(1);2.O(log n);3.O(n);4.O(n²)', 1),

    (12, 'FILL_BLANK', '배열을 순차적으로 접근할 때, 성능이 좋은 이유는 _____지역성 때문이다.', '캐시', '-', 1);

-- Unit02 - 연결리스트 2 (Lesson ID: 3)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (25, 'FILL_BLANK', '선형 양방향 연결리스트에서 헤드노드의 prev 포인터와 테일노드의 next 포인터는 _____을 가리킨다', 'null', '-', 3),

    (26, 'FILL_BLANK', '원형 양방향 연결리스트에서 테일노드의 next 포인터는 _____노드를 가리킨다.', '헤드, 머리', '-', 3),

    (27, 'FILL_BLANK', '선형 양방향 연결리스트에서 첫번째 노드는 _____노드의 next를 통해 접근할 수 있다.', '헤드, 머리', '-', 3),

    (28, 'FILL_BLANK', '원형 양방향 연결리스트에서 마지막 노드는 _____노드의 prev를 통해 접근할 수 있다.', '테일, 꼬리', '-', 3),

    (29, 'SELECT_DESCRIPTION', '양방향 연결리스트의 중간에 새로운 노드를 삽입하기 위해서는 몇 개의 포인터를 수정해야 하는가?', '1', '1.2개;2.3개;3.4개;4.5개', 3),

    (30, 'SELECT_DESCRIPTION', '양방향 연결리스트의 중간에 위치한 노드를 삭제하기 위해서는 몇 개의 포인터를 수정해야 하는가?', '1', '1.2개;2.3개;3.4개;4.5개', 3),

    (31, 'SELECT_DESCRIPTION', '원형 양방향 연결리스트에서 임의의 노드에서 시작해서 전체 노드를 한번 순회하는 연산의 시간복잡도는?', '3', '1.O(1);2.O(log n);3.O(n);4.O(n²)', 3),

    (32, 'SELECT_DESCRIPTION', '테일노드를 사용한 경우, 마지막 원소에 대한 삽입/삭제 연산의 시간복잡도는 _____이 된다.', '1', '1.O(1);2.O(log n);3.O(n);4.O(n²)', 3),

    (33, 'SELECT_DESCRIPTION', '양방향 연결리스트를 통해 구현할 수 있는 자료구조가 아닌 것은?', '4', '1.스택;2.큐;3.덱;4.힙', 3);

-- Unit03 - 스택 (Lesson ID: 4)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (34, 'SELECT_DESCRIPTION', '스택에 3, 5, 1, 2를 순차적으로 넣었을 때, 가장 위에 있는 원소는?', '4', '1.3;2.5;3.1;4.2', 4),

    (35, 'FILL_BLANK', '스택은 _____ 구조를 따른다.', 'lifo, 후입선출', '-', 4),

    (36, 'SELECT_DESCRIPTION', '스택은 _____의 원소만 접근이 가능하다.', '2', '1.맨 아래;2.맨 위;3.가운데;4.임의', 4),

    (37, 'FILL_BLANK', '스택의 맨 위 원소를 _____이라고 한다.', '탑, top', '-', 4),

    (38, 'FILL_BLANK', '배열로 구현된 스택에서 아무 원소도 들어있지 않은 상황이라면, top을 가리키는 인덱스는 _____으로 초기화되어 있다.', '-1', '1.-999;2.-1;3.0;4.1', 4),

    (39, 'SELECT_DESCRIPTION', '연결리스트로 구현된 스택에서 원소 삽입이 발생하면 몇 개의 포인터가 변경되는가?', '2', '1.1개;2.2개;3.3개;4.4개', 4),

    (40, 'SELECT_DESCRIPTION', '연결리스트로 구현된 스택에서 원소 삭제가 발생하면 몇 개의 포인터가 변경되는가?', '1', '1.1개;2.2개;3.3개;4.4개', 4),

    (41, 'SELECT_DESCRIPTION', '후위표현법 "3 4 + 2"를 계산하면?', '2', '1.11;2.14;3.10;4.24', 4),

    (42, 'SELECT_DESCRIPTION', '후위표현법 "5 3 - 2 4 + *"을 계산하면?', '1', '1.12;2.10;3.8;4.6', 4),

    (43, 'SELECT_DESCRIPTION', '스택의 push, pop, peek 연산의 시간복잡도는?', '1', '1.O(1);2.O(log n);3.O(n);4.O(n²)', 4);

-- Unit04 - 큐 (Lesson ID: 5)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (44, 'SELECT_DESCRIPTION', '큐에 2, 9, 7, 4를 순차적으로 넣었을 때, 원소 삭제시 반환되는 값은?', '1', '1.2;2.9;3.7;4.4', 5),

    (45, 'FILL_BLANK', '큐는 _____ 구조를 따른다.', 'fifo, 선입선출', '-', 5),

    (46, 'SELECT_DESCRIPTION', '큐를 구현할 때, 주로 원형 구조를 사용하는 이유는?', '1', '1.낭비되는 공간을 재사용하기 위해;2.삽입/삭제 연산 속도를 높이기 위해;3.메모리 할당을 동적으로 하기 위해;4.데이터의 순서를 보장하기 위해', 5),

    (47, 'FILL_BLANK', '원형 배열로 구현된 크기가 n인 빈 큐에서 tail과 front가 가리키고 있는 인덱스는?', 'n-1, 0', '1.0, 0;2.0, 1;3.n-1, 0;4.n, 0', 5),

    (48, 'FILL_BLANK', '원형 배열로 구현된 크기가 8인 빈 큐에서 삽입 3회, 삭제 1회가 일어났을 때 tail이 가리키는 인덱스는 _____이다.', '2', '-', 5),

    (49, 'FILL_BLANK', '원형 배열로 구현된 크기가 8인 빈 큐에서 삽입 4회, 삭제 3회가 일어났을 때 tail이 가리키는 인덱스는 _____이다.', '3', '-', 5),

    (50, 'SELECT_DESCRIPTION', '원형 연결리스트로 큐를 구현할 때, tail 포인터만 사용하는 이유는?', '1', '1.tail -> next가 front를 가리키기 때문;2.front 개념이 존재하지 않음;3.tail 포인터가 더 빠른 접근을 제공;4.연산 속도가 더 빠름', 5),

    (51, 'FILL_BLANK', '원형 연결리스트로 구현된 큐에서 새로운 노드를 추가하는 경우 수정되는 포인터의 수는 _____개이다.', '3', '-', 5),

    (52, 'FILL_BLANK', '원형 연결리스트로 구현된 큐에서 노드를 삭제하는 경우 수정되는 포인터의 수는 _____개이다.', '1', '-', 5),

    (53, 'SELECT_DESCRIPTION', '스택을 이용해 문자열 "abba"가 회문(좌우동형)인지 검사할 때, 스택에 저장할 문자는?', '1', '1.a, b;2.a, b, b, a;3.b, b;4.a, a', 5),

    (54, 'FILL_BLANK', '스택을 이용한 회문 검사에서 문자열 "level"의 경우, 스택에는 _____개의 문자를 저장한다.', '2', '-', 5);

-- Unit05 - 힙 (Lesson ID: 6)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (55, 'FILL_BLANK', '_____ _____를 구현한 자료구조를 힙이라고 한다.', '우선순위 큐', '-', 6),

    (56, 'FILL_BLANK', '힙은 _____ _____ 트리 구조를 사용한다.', '완전 이진, 완전이진', '-', 6),

    (57, 'SELECT_DESCRIPTION', '모든 노드가 자식 노드보다 크거나 같은 값을 갖는 힙은?', '최대힙', '-', 6),

    (58, 'SELECT_DESCRIPTION', '모든 노드가 자식 노드보다 작거나 같은 값을 갖는 힙은?', '최소힙', '-', 6),

    (59, 'SELECT_DESCRIPTION', '힙을 배열로 구현했을 때 부모노드의 인덱스가 k인 경우, 자식노드에 접근할 수 있는 인덱스는?', '2', '1.2k;2.2k+1;3.2k-1;4.2k-2', 6),

    (60, 'SELECT_DESCRIPTION', '힙을 배열로 구현했을 때 자식노드의 인덱스가 k인 경우, 부모노드에 접근할 수 있는 인덱스는?', '3', '1.(k-1) / 2의 올림;2.(k-2) / 2의 올림;3.(k-1) / 2의 내림;4.(k-2) / 2의 내림', 6),

    (61, 'SELECT_DESCRIPTION', '배열로 구현한 최대힙에 8 | 7 | 5 | 3 순으로 원소가 들어가 있다. 만약, 9를 힙에 넣게 되면 총 몇번의 교환 연산이 일어나는가?', '2번', '-', 6),

    (62, 'SELECT_DESCRIPTION', '배열로 구현한 최대힙에 10 | 8 | 6 | 7 | 4 | 5 | 2 순으로 원소가 들어가 있다. 만약, 12를 힙에 넣게 되면 총 몇번의 교환 연산이 일어나는가?', '3', '1.1번;2.2번;3.3번;4.4번', 6),

    (63, 'SELECT_DESCRIPTION', '배열로 구현한 최대힙에 15 | 12 | 10 | 8 | 9 | 6 | 7 | 3 | 5 순으로 원소가 들어가 있다. 만약, 14를 힙에 넣게 되면 총 몇번의 교환 연산이 일어나는가?', '2', '1.1번;2.2번;3.3번;4.0번', 6),

    (64, 'SELECT_DESCRIPTION', '배열로 구현한 최대힙에 16 | 12 | 14 | 8 | 10 | 6 | 9 | 4 | 7 순으로 원소가 들어가 있다. 루트 노드를 삭제할 때 총 몇번의 교환 연산이 일어나는가?', '3', '-', 6),

    (65, 'SELECT_DESCRIPTION', '배열로 구현한 최대힙에 18 | 15 | 16 | 10 | 12 | 8 | 14 | 4 | 6 | 9 순으로 원소가 들어가 있다. 루트 노드 삭제 및 스며내리기 과정이 완료된 후, 스며내리기 대상이었던 값의 최종 인덱스는?', '6', '-', 6);

-- Unit06 - 해시 (Lesson ID: 7)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (66, 'FILL_BLANK', '해시 테이블의 조회, 삽입, 삭제 연산의 시간복잡도는 _____이다.', 'o(1)', '1.O(1);2.O(log n);3.O(n);4.O(n²)', 7),

    (67, 'FILL_BLANK', '해시 함수가 " h(x) = x % 10 " 라고할 때, key로 13과 3이 들어오면 같은 해시값을 갖게 되는데 이를 _____이라고 한다.', '충돌', '-', 7),

    (68, 'SELECT_DESCRIPTION', '해시 테이블에서 전체 크기 대비 원소가 차 있는 비율을 무엇이라고 하는가?', '1', '1.적재율;2.충돌율;3.성공률;4.이용률', 7),

    (69, 'FILL_BLANK', '해시 테이블에서 충돌이 발생한 원소들을 같은 버킷에 연결 리스트로 관리하는 방식을 _____이라고 한다.', '체이닝, 채이닝, chaining', '-', 7),

    (70, 'SELECT_DESCRIPTION', '해시 테이블에서 체이닝 방식으로 충돌을 해결하는 경우, 조회 연산에 대한 최악의 경우 시간복잡도는?', '3', '1.O(1);2.O(log n);3.O(n);4.O(n²)', 7),

    (71, 'FILL_BLANK', '해시 테이블에서 충돌이 발생했을 때, 테이블 내의 다른 빈 공간을 찾아 저장하는 방식을 _____ _____ 법이라고 한다.', '개방 주소', '-', 7),

    (72, 'SELECT_DESCRIPTION', '개방 주소 방법에서 충돌이 발생했을 때 h(k), h(k)+1, h(k)+2, ... 순서로 빈 슬롯을 찾아 탐색하는 방식은?', '1', '1.선형 탐사법;2.이차 탐사법;3.이중 해싱;4.랜덤 탐사법', 7),

    (73, 'SELECT_DESCRIPTION', '개방 주소법에서 충돌이 발생했을 때 h(k), h(k)+1², h(k)+2², h(k)+3²... 순서로 탐색하는 방식은?', '2', '1.선형 탐사법;2.이차 탐사법;3.이중 해싱;4.랜덤 탐사법', 7),

    (74, 'SELECT_DESCRIPTION', '개방 주소법에서 두 개의 서로 다른 해시 함수를 사용하여 충돌을 해결하는 방식은?', '3', '1.선형 탐사법;2.이차 탐사법;3.이중 해싱;4.랜덤 탐사법', 7),

    (75, 'SELECT_DESCRIPTION', '선형 탐사법에서 연속된 해시 슬롯들이 채워지면서 데이터가 한 곳에 뭉치는 현상을 무엇이라고 하는가?', '1', '1.1차 군집;2.2차 군집;3.해시 충돌;4.로드 팩터', 7),

    (76, 'SELECT_DESCRIPTION', '선형 탐사법에서 1차 군집 현상이 성능에 미치는 영향으로 가장 적절한 것은?', '2', '1.메모리 사용량이 증가한다;2.평균 탐색 시간이 길어진다;3.해시 함수의 성능이 저하된다;4.적재율이 감소한다', 7);

-- Unit07 - 트리 1 (Lesson ID: 8)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (77, 'FILL_BLANK', '트리(Tree)란 _____들이 나무 가지처럼 연결된 자료구조이다.', '노드, node', '-', 8),

    (78, 'FILL_BLANK', '각 노드와 노드는 _____으로 연결된다.', '간선, edge', '-', 8),

    (79, 'SELECT_DESCRIPTION', '트리에서 최상위에 위치한 노드를 무엇이라고 하는가?', '4', '1.부모 노드;2.자식 노드;3.리프 노드;4.루트 노드', 8),

    (80, 'SELECT_DESCRIPTION', '트리에서 자식 노드를 갖고있지 않는 노드를 무엇이라고 하는가?', '3', '1.부모 노드;2.자식 노드;3.리프 노드;4.부모 노드', 8),

    (81, 'FILL_BLANK', '노드가 n개인 트리는 _____개의 간선을 갖고 있다.', 'n-1', '1.2n;2.n;3.n+1;4.n-1', 8),

    (82, 'FILL_BLANK', '트리에서 루트 노드부터 특정 노드까지의 거리를 그 노드의 _____라고 한다.', '깊이, depth', '-', 8),

    (83, 'SELECT_DESCRIPTION', '이진 트리에서 각 노드가 가질 수 있는 최대 자식 노드의 개수는?', '2', '1.1개;2.2개;3.3개;4.제한 없음', 8),

    (84, 'FILL_BLANK', '한 노드에서 다른 노드로 가는 일련의 간선들을 _____라고 한다.', '경로, path', '-', 8),

    (85, 'SELECT_DESCRIPTION', '트리에서 사이클(순환)이 존재하는가?', '2', '1.항상 존재한다;2.존재하지 않는다;3.경우에 따라 다르다;4.루트 노드에만 존재한다', 8),

    (86, 'FILL_BLANK', '트리에서 한 노드가 갖고 있는 자식 노드의 개수를 그 노드의 _____라고 한다.', '차수, degree', '-', 8);

-- Unit07 - 트리 2 (Lesson ID: 9)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (87, 'SELECT_DESCRIPTION', '높이가 5인 이진트리에서 가질 수 있는 최대 노드의 개수는?', '63', '-', 9),

    (88, 'FILL_BLANK', '이진트리에서 현재 노드, 왼쪽 자식 노드, 오른쪽 자식 노드 순서로 방문하는 순회방식을 _____순회라고 한다.', '전위, preorder', '-', 9),

    (89, 'FILL_BLANK', '이진트리에서 왼쪽 자식 노드, 현재 노드, 오른쪽 자식 노드 순서로 방문하는 순회방식을 _____순회 라고 한다.', '중위, inorder', '-', 9),

    (90, 'FILL_BLANK', '이진트리에서 왼쪽 자식 노드, 오른쪽 자식 노드, 현재 노드 순서로 방문하는 순회방식을 _____순회 라고 한다.', '후위, postorder', '-', 9),

    (91, 'SELECT_DESCRIPTION', '이진탐색트리의 성질로 올바른 것은?', '2', '1.부모노드 > 왼쪽 자식노드 > 오른쪽 자식노드;2.오른쪽 자식노드 > 부모노드 > 왼쪽 자식노드;3.왼쪽 자식노드 > 부모노드 > 오른쪽 자식노드;4.부모노드 > 오른쪽 자식노드 > 왼쪽 자식노드', 9),

    (92, 'SELECT_DESCRIPTION', '균형잡힌 이진탐색트리에서 특정 값을 조회하는데 걸리는 시간복잡도는?', '2', '1.O(1);2.O(log n);3.O(n);4.O(n log n)', 9),

    (93, 'SELECT_DESCRIPTION', '균형잡힌 이진탐색트리에서 특정 값을 삽입/삭제하는데 걸리는 시간복잡도는?', '2', '1.O(1);2.O(log n);3.O(n);4.O(n log n)', 9),

    (94, 'FILL_BLANK', '모든 레벨이 완전하게 채워져 있고, 마지막 레벨의 모든 노드가 존재하는 이진트리를 _____이진트리라고 한다.', '포화', '-', 9),

    (95, 'SELECT_DESCRIPTION', '완전이진트리의 특징으로 올바른 것은?', '2', '1.모든 레벨이 완전히 채워져 있다;2.마지막 레벨을 제외하고 모든 레벨이 채워져 있으며, 마지막 레벨은 왼쪽부터 채워진다.;3.같은 레벨에 있는 노드의 값은 항상 동일하다.;4.모든 리프노드의 높이는 최대 2까지 차이난다.', 9),

    (96, 'SELECT_DESCRIPTION', '완전이진트리를 구현할 때, 가장 적합한 자료구조는?', '1', '1.배열;2.연결 리스트;3.스택;4.힙', 9);

-- Unit07 - 트리 3 (Lesson ID: 10)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (97, 'FILL_BLANK', '각 노드가 블랙 또는 레드 색상으로 표기되며, 특정 규칙을 통해 스스로 균형을 유지하는 이진탐색트리를 _____트리라고 한다.', '레드블랙, 레드 블랙, 레드-블랙, red-black', '-', 10),

    (98, 'FILL_BLANK', '레드-블랙트리에서 루트 노드의 색상은 _____이다', '블랙, 블렉, black, 검은색', '-', 10),

    (99, 'FILL_BLANK', '레드-블랙트리에서 자식이 없는 모든 노드는 _____ 노드를 갖고있다.', 'nil', '-', 10),

    (100, 'FILL_BLANK', '레드-블랙트리에서 새 노드를 삽입할 경우 _____ 색상으로 설정한다.', '레드, 빨간, 빨강, red', '-', 10),

    (101, 'SELECT_DESCRIPTION', '레드-블랙 트리의 탐색, 삽입, 삭제 연산의 시간복잡도는?', '2', '1.O(1);2.O(log N);3.O(N);4.O(N log N)', 10),

    (102, 'FILL_BLANK', '힙은 항상 _____이진트리의 형태를 유지해야 한다.', '완전', '-', 10),

    (103, 'SELECT_DESCRIPTION', '힙에서 특정 데이터의 삽입/삭제 연산의 시간복잡도는?', '2', '1.O(1);2.O(log N);3.O(N);4.O(N log N)', 10),

    (104, 'SELECT_DESCRIPTION', '최대 힙에서 새로운 데이터를 삽입하는 과정으로 올바른 것은?', '2', '1.루트노드에 삽입 후 아래로 내려감;2.마지막 노드에 삽입 후 위로 올라감;3.임의의 위치에 삽입하고 정렬함;4.왼쪽 자식부터 삽입함', 10);


-- Chapter 2
-- Unit08 - 정렬 1 (Lesson ID: 11)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (105, 'SELECT_DESCRIPTION', '다음 중 기본적으로 불안정(unstable) 인 정렬은?', '2', '1.버블정렬;2.선택정렬;3.삽입정렬;4.기수정렬(LSD, 안정 카운팅 사용)', 11),

    (106, 'SELECT_DESCRIPTION', '입력이 이미 정렬되어 있을 때 Θ(n) 시간에 끝낼 수 있는 정렬은?', '3', '1.버블정렬(조기종료 미적용);2.선택정렬;3.삽입정렬;4.기수정렬', 11),

    (107, 'SELECT_DESCRIPTION', '길이 n 배열에서 선택 정렬의 총 비교 횟수는? (빅-Θ)', '3', '1.Θ(n);2.Θ(n log n);3.Θ(n²);4.Θ(n³)', 11),

    (108, 'SELECT_DESCRIPTION', '교환(swaps) 횟수가 항상 O(n) 인 정렬은?', '2', '1.버블정렬;2.선택정렬;3.삽입정렬;4.기수정렬', 11),

    (109, 'SELECT_DESCRIPTION', '버블정렬에서 i번째 패스가 끝나면 성립하는 사실은?', '2', '1.첫 i개의 원소가 정렬 완료;2.마지막 i개의 원소가 정렬 위치에 고정;3.중간 i개의 원소가 정렬 완료;4.어떤 부분도 보장되지 않음', 11),

    (110, 'SELECT_DESCRIPTION', '입력을 한 원소씩 읽으며 접두 구간을 항상 정렬 상태로 유지하는 정렬은?', '3', '1.버블정렬;2.선택정렬;3.삽입정렬;4.기수정렬', 11),

    (111, 'SELECT_DESCRIPTION', '기수정렬(LSD, 각 자리 안정 정렬) 시간복잡도는 자리수 d, 기수 k, 입력 크기 n일 때?', '2', '1.Θ(n log n);2.Θ(d·(n + k));3.Θ(d·k·log n);4.Θ(n² / d)', 11),

    (112, 'SELECT_DESCRIPTION', 'LSD 기수정렬에서 각 자리를 정렬할 때 반드시 필요한 성질은?', '2', '1.불안정 정렬;2.안정 정렬;3.비교 기반 정렬;4.제자리(in-place) 정렬', 11),

    (113, 'SELECT_DESCRIPTION', '배열 [5, 1, 4, 2]에 버블정렬 첫 패스(왼→오) 후 배열은?', '1', '1.[1, 4, 2, 5];2.[1, 5, 4, 2];3.[4, 1, 2, 5];4.[5, 4, 2, 1]', 11),

    (114, 'SELECT_DESCRIPTION', '삽입정렬의 이동(shift) 횟수는 어떤 값과 가장 밀접히 비례하는가?', '1', '1.역순쌍(인버전) 개수;2.최대값의 크기;3.최소값의 위치;4.중복 원소의 수', 11),

    (115, 'SELECT_DESCRIPTION', '거의 정렬된 작은 데이터에 가장 적합한 것은?', '3', '1.버블정렬;2.선택정렬;3.삽입정렬;4.기수정렬', 11),

    (116, 'SELECT_DESCRIPTION', '다음 중 O(n + k) 의 추가 메모리가 필요한 것은?', '4', '1.버블정렬;2.선택정렬;3.삽입정렬;4.기수정렬', 11);

-- Unit08 - 정렬 2 (Lesson ID: 12)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (117, 'SELECT_DESCRIPTION', '다음 중 기본적으로 안정적(stable)인 정렬은?', '3', '1.힙정렬;2.퀵정렬;3.병합정렬;4.모두 불안정', 12),

    (118, 'SELECT_DESCRIPTION', 'O(1) 보조 메모리(제자리)로 수행되는 것은?', '2', '1.병합정렬;2.힙정렬;3.퀵정렬(재귀 스택 제외);4.카운팅정렬', 12),

    (119, 'SELECT_DESCRIPTION', '최악의 경우 Θ(n²)이 될 수 있는 것은?', '2', '1.힙정렬;2.퀵정렬;3.병합정렬;4.위 모두 아님', 12),

    (120, 'SELECT_DESCRIPTION', '퀵정렬의 평균 성능을 안정화하는 전략으로 적절한 것은?', '3', '1.항상 첫 원소를 피벗;2.항상 마지막 원소를 피벗;3.랜덤 피벗 선택;4.정렬된 입력에서 중앙값을 피벗', 12),

    (121, 'SELECT_DESCRIPTION', '배열을 한 번에 힙으로 만드는 Floyd의 build-heap 시간은?', '1', '1.Θ(n);2.Θ(n log n);3.Θ(log n);4.Θ(n²)', 12),

    (122, 'SELECT_DESCRIPTION', '최대 힙을 이용해 힙에서 원소를 하나씩 꺼내 출력하면, 출력되는 값들의 순서는?', '2', '1.오름차순;2.내림차순;3.입력과 동일;4.무작위', 12),

    (123, 'SELECT_DESCRIPTION', '배열 기반 병합 정렬에서 일반적으로 필요한 추가 공간은?', '4', '1.Θ(1);2.Θ(log n);3.Θ(√n);4.Θ(n)', 12),

    (124, 'SELECT_DESCRIPTION', '배열의 역순쌍(인버전)을 효율적으로 세는 데 적합한 방법은?', '2', '1.힙정렬 수정;2.병합정렬 응용;3.퀵정렬 응용;4.버킷정렬', 12),

    (125, 'SELECT_DESCRIPTION', '퀵정렬의 파티션이 끝난 직후 피벗 p에 대해 참인 것은?', '3', '1.p보다 작은 원소가 모두 오른쪽에 있다;2.p보다 큰 원소가 모두 왼쪽에 있다;3.p는 최종 위치에 있고, 왼쪽 ≤ p, 오른쪽 ≥ p가 된다;4.정렬이 모두 끝난다', 12),

    (126, 'SELECT_DESCRIPTION', '메모리에 다 안 들어가는 매우 큰 데이터를 정렬할 때 적합한 방법은?', '2', '1.힙정렬;2.병합정렬(외부 정렬);3.퀵정렬;4.삽입정렬', 12),

    (127, 'SELECT_DESCRIPTION', '퀵정렬에서 분할이 거의 균등할 때 각 재귀 레벨의 총 작업량과 높이는?', '1', '1.레벨 합 Θ(n), 높이 Θ(log n);2.레벨 합 Θ(log n), 높이 Θ(n);3.레벨 합 Θ(n log n), 높이 Θ(n);4.레벨 합 Θ(1), 높이 Θ(log n)', 12),

    (128, 'SELECT_DESCRIPTION', '힙정렬이 기본적으로 불안정한 가장 큰 이유는?', '2', '1.비교 기반이 아니라서;2.루트-말단 교환으로 동일 키의 상대 순서가 뒤섞일 수 있어서;3.힙 구성 비용이 커서;4.재귀가 깊어서', 12);

-- Unit09 - 그리디 알고리즘 1 (Lesson ID: 13)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (129, 'SELECT_DESCRIPTION', '다음 중 그리디 알고리즘 설명으로 가장 가까운 것은?', '2', '1.모든 경우를 다 탐색해 최적을 찾는다;2.현재 순간 최선처럼 보이는 선택을 한다;3.이전 결과를 저장하고 그 값을 활용한다;4.무작위로 선택해도 평균적으로 맞는다', 13),

    (130, 'FILL_BLANK', '그리디-초이스 프로퍼티는 "지금 고른 선택을 포함하는 _____가 적어도 하나 존재한다"는 뜻이다.', '최적해', '1.해답 후보;2.국소해;3.최적해;4.근사해', 13),

    (131, 'FILL_BLANK', '교환 논법은 임의의 최적해가 있을 때 그 해의 일부를 그리디가 고른 선택으로 _____해의 품질이 나빠지지 않음을 보이는 방법이다.', '바꿔도', '1.추가해도;2.제거해도;3.바꿔도;4.섞어도', 13),

    (132, 'SELECT_DESCRIPTION', '전형적으로 그리디가 최적을 보장하는 문제는?', '2', '1.0-1 배낭 최적값;2.겹치지 않는 구간(회의) 최대 개수 선택;3.음수 간선 허용 최단경로;4.임의 동전 체계 거스름돈', 13),

    (133, 'SELECT_DESCRIPTION', '동전 {1,5,10,50,100,500}으로 760원을 최소 개수로 거슬러줄 때 동전 개수는?', '2', '1.4개;2.5개;3.6개;4.7개', 13),

    (134, 'SELECT_DESCRIPTION', '동전 {1,3,4}로 6원을 거슬러줄 때 그리디와 최적해는?', '1', '1.그리디=3개(4+1+1), 최적=2개(3+3);2.그리디=2개(3+3), 최적=3개(4+1+1);3.둘 다 2개;4.둘 다 3개', 13),

    (135, 'SELECT_DESCRIPTION', '동전 {1,3,4}에서 큰 동전 우선 그리디가 처음 실패하는 최소 금액은?', '3', '1.4;2.5;3.6;4.7', 13),

    (136, 'SELECT_DESCRIPTION', '새 동전 체계에서 그리디의 올바름을 빠르게 점검하는 방법은?', '2', '1.임의의 큰 금액 하나만 테스트;2.작은 금액부터 1~N까지 최적과 비교해 반례 탐색;3.동전 개수만 세면 된다;4.항상 맞다고 가정한다', 13),

    (137, 'SELECT_DESCRIPTION', '분할 가능 배낭에서 가치 최대화를 위한 전형적 정렬 기준은?', '3', '1.무게 오름차순;2.가치 오름차순;3.가치/무게 비율 내림차순;4.무작위', 13),

    (138, 'SELECT_DESCRIPTION', '(무게, 가치) → A(4,20), B(2,14), C(6,24), 용량 7. 분할 가능 배낭 그리디의 최대 가치는?', '2', '1.36;2.38;3.40;4.42', 13),

    (139, 'SELECT_DESCRIPTION', '0-1 배낭에서 비율 내림차순 그리디는 항상 최적인가?', '1', '1.아니다. 반례가 있다;2.그렇다. 항상 최적이다;3.물건이 2개면 항상 최적이다;4.용량이 크면 항상 최적이다', 13),

    (140, 'SELECT_DESCRIPTION', '0-1 배낭에서 비율 그리디가 실패하는 핵심 이유는?', '2', '1.교환 논법을 적용할 수 없다;2.물건을 쪼갤 수 없어 부분 채움 이득을 쓰지 못한다;3.비율 계산이 부정확하다;4.정렬이 비안정이라서', 13);

-- Unit09 - 그리디 알고리즘 2 (Lesson ID: 14)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (141, 'SELECT_DESCRIPTION', '서로 겹치지 않는 구간을 최대 개수로 선택하려면 어떤 정렬 기준이 적절한가?', '3', '1.시작 시간 오름차순;2.길이(끝-시작) 오름차순;3.끝나는 시간 오름차순;4.이득/시간 비율 내림차순', 14),

    (142, 'SELECT_DESCRIPTION', '작업들의 마감시간이 주어질 때 최대 지연을 최소로 만드는 단일 머신 스케줄링 규칙은?', '3', '1.시작 시간 오름차순;2.처리 시간 짧은 순(SPT);3.마감 시간 오름차순(EDD);4.가치/시간 비율 내림차순', 14),

    (143, 'SELECT_DESCRIPTION', 'd는 마감 시간, 하나의 머신만 사용. J1(d=2, 이익=60), J2(d=1, 이익=100), J3(d=2, 이익=20). 총 이익을 최대로 하는 그리디 선택은?', '1', '1.{J1, J2};2.{J1, J3};3.{J2, J3};4.{J1, J2, J3}', 14),

    (144, 'SELECT_DESCRIPTION', '구간 [1,4], [2,5], [3,6], [7,9]를 모두 배치할 때 필요한 최소 회의실 수는?', '3', '1.1;2.2;3.3;4.4', 14),

    (145, 'SELECT_DESCRIPTION', '빈도 A=5, B=7, C=10, D=15일 때 Huffman 트리의 총 비용(병합 합의 합)은?', '2', '1.69;2.71;3.72;4.73', 14),

    (146, 'SELECT_DESCRIPTION', '빈도 A=2, B=3, C=7, D=9에서 첫 병합 쌍은?', '1', '1.(A,B);2.(A,C);3.(B,C);4.(C,D)', 14),

    (147, 'SELECT_DESCRIPTION', '다음 중 접두부(prefix-free) 코드인 것은?', '1', '1.{A:0, B:10, C:110, D:111};2.{A:0, B:01, C:011, D:0111};3.{A:1, B:10, C:101, D:1011};4.{A:0, B:00, C:10, D:11}', 14),

    (148, 'SELECT_DESCRIPTION', 'Huffman 코딩은 무엇을 최소화하는 그리디 알고리즘인가?', '2', '1.최대 코드 길이;2.평균(기대) 코드 길이;3.심볼 개수;4.엔트로피', 14),

    (149, 'SELECT_DESCRIPTION', '우주 U={1,2,3,4,5,6,7}, 집합 S1={1,2,3,4}, S2={3,4,5}, S3={5,6,7}, S4={6,7}. 무가중치 그리디(아직 덮지 않은 원소를 가장 많이 덮는 집합)를 적용할 때 선택 순서는?', '1', '1.S1 → S3;2.S3 → S1;3.S1 → S4;4.S2 → S3', 14),

    (150, 'SELECT_DESCRIPTION', 'U={a,b,c,d,e}, A={a,b,c}(비용3), B={c,d,e}(비용2), C={a,e}(비용1). 가중치 그리디(단위 비용당 신규 커버 수 최대)를 처음 적용할 때 선택은?', '3', '1.A;2.B;3.C', 14),

    (151, 'FILL_BLANK', '가중치가 있을 때 그리디는 매 단계 _____가 최대인 집합을 고른다.', '신규 커버 수/비용', '1.비용/신규 커버 수;2.신규 커버 수/비용;3.전체 크기;4.이미 덮인 원소 수', 14),

    (152, 'SELECT_DESCRIPTION', '무가중치 Set Cover에 대한 고전적 그리디 알고리즘의 근사 보장은?', '3', '1.항상 최적;2.2-근사;3.H(n)≈ln|U| 근사;4.보장 없음', 14);

-- Unit10 - BFS, DFS (Lesson ID: 15)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (153, 'SELECT_DESCRIPTION', 'DFS(깊이 우선 탐색)와 BFS(너비 우선 탐색)의 가장 중요한 차이점은?', '3', '1.DFS는 모든 노드를 방문하지만, BFS는 일부만 방문한다;2.DFS는 재귀를 사용하고 BFS는 반복문을 사용한다;3.DFS는 깊게 탐색하고 BFS는 넓게 탐색한다;4.DFS는 최단 경로를 보장하지만, BFS는 그렇지 않다', 15),

    (154, 'SELECT_DESCRIPTION', 'BFS(너비 우선 탐색)에서 일반적으로 사용하는 자료구조는?', '2', '1.스택;2.큐;3.힙;4.해시테이블', 15),

    (155, 'SELECT_DESCRIPTION', 'DFS(깊이 우선 탐색)에서는 일반적으로 _____나 재귀호출을 사용한다.', '스택', '-', 15),

    (156, 'SELECT_DESCRIPTION', '가중치가 없는 그래프에서 최단 경로를 찾기에 적합한 알고리즘은?', '2', '1.DFS;2.BFS;3.DFS, BFS 둘 다;4.둘 다 불가능', 15),

    (157, 'FILL_BLANK', 'DFS와 BFS 모두 그래프 탐색 시 무한루프를 방지하기 위해 노드의 _____ 여부를 반드시 검사해야 한다.', '방문, 탐색, 검사', '-', 15),

    (158, 'SELECT_DESCRIPTION', 'DFS의 주요 특징이 아닌 것은?', '3', '1.재귀적으로 구현 가능;2.백트래킹에 사용;3.FIFO 원칙으로 동작;4.메모리 사용량이 적음', 15),

    (159, 'SELECT_DESCRIPTION', 'BFS가 DFS보다 유리한 상황은?', '3', '1.모든 노드를 방문해야 할 때;2.메모리 사용량을 줄여야 할 때;3.시작점에서 목표점까지의 최단 거리를 구할 때;4.깊은 단계의 해를 찾을 때', 15),

    (160, 'SELECT_DESCRIPTION', 'V개의 정점과 E개의 간선을 가진 그래프에서 BFS의 시간복잡도는?', '1', '1.O(V + E);2.O(V × E);3.O(V²);4.O(E log V)', 15),

    (161, 'SELECT_DESCRIPTION', 'V개의 정점과 E개의 간선을 가진 그래프에서 DFS의 시간복잡도는?', '1', '1.O(V + E);2.O(V × E);3.O(V²);4.O(E log V)', 15);

-- Unit11 - Dynamic Programming (Lesson ID: 16)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (162, 'FILL_BLANK', '동적 프로그래밍(DP)에서 한 번 계산된 결과를 저장해 두었다가, 같은 문제가 호출되었을 때 저장된 결과를 사용하는 기법을 _____이라고 한다.', '메모이제이션, memoization', '-', 16),

    (163, 'SELECT_DESCRIPTION', '동적 프로그래밍(DP)이 적용되기 위한 필수 조건이 아닌 것은?', '3', '1.중복 부분 문제;2.최적 부분 구조;3.정렬된 입력 데이터;4.점화식 도출 가능', 16),

    (164, 'FILL_BLANK', '피보나치 수열에서 F(n) = F(n-1) + F(n-2)와 같은 수식을 _____식이라고 한다.', '점화', '-', 16),

    (165, 'FILL_BLANK', 'Top-down 방식은 재귀 함수와 메모이제이션을 사용하고 Bottom-up 방식은 _____문을 사용한다.', '반복', '-', 16),

    (166, 'FILL_BLANK', '동적 프로그래밍(DP)에서 작은 문제들의 최적해가 큰 문제의 최적해에 포함되는 성질을 _____ _____구조라고 한다.', '최적 부분, 최적부분', '-', 16),

    (167, 'SELECT_DESCRIPTION', '용량이 13인 배낭에 무게와 가치가 각각 (3,6), (4,8), (5,9), (6,11), (2,4), (4,7)인 물건들이 있을 때, 최적해에서 선택되는 물건의 개수는?', '4개', '-', 16),

    (168, 'SELECT_DESCRIPTION', '편집 거리 문제에서 문자열 길이가 각각 m, n일 때 2차원 DP 테이블의 크기와 시간복잡도는?', '4', '1.(m×n), O(mn);2.(m+n), O(m+n);3.(m×n), O(m²n²);4.(m+1)×(n+1), O(mn)', 16),

    (169, 'SELECT_DESCRIPTION', '최장 증가 부분 수열(LIS) 문제에서 배열 [1, 3, 2, 5, 4, 7, 6, 8]의 LIS 길이는?', '5', '-', 16),

    (170, 'FILL_BLANK', '동적 프로그래밍을 적절히 사용하면 지수 시간복잡도를 _____ 시간복잡도로 개선할 수 있다.', '다항식', '-', 16);

-- Unit12 - 다익스트라 알고리즘 (Lesson ID: 17)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (171, 'FILL_BLANK', '다익스트라 알고리즘은 _____의 가중치가 없는 그래프의 한 정점에서 모든 정점까지의 최단 경로를 구하는 알고리즘이다.', '음, -', '-', 17),

    (172, 'FILL_BLANK', '다익스트라 알고리즘의 메커니즘은 방문하지 않은 정점 중에서 가장 적은 비용의 정점을 선택한다는 점에서 _____ 알고리즘의 성질을 가지고 있다고 볼 수 있다.', '그리디', '-', 17),

    (173, 'FILL_BLANK', '다익스트라 알고리즘의 메커니즘은 선택된 노드로부터 갈 수 있는 노드들의 비용을 갱신한다는 점에서 _____의 성질을 가지고 있다고 볼 수 있다.', 'dp, dynamic programming, 디피, 동적 계획법, 동적 프로그래밍', '-', 17),

    (174, 'FILL_BLANK', '다익스트라 알고리즘에서 거리 배열을 초기화할 때, 출발점은 0으로 나머지 정점들은 _____로 설정한다.', '무한대, inf, ∞', '-', 17),

    (175, 'SELECT_DESCRIPTION', '5개 노드로 구성된 완전 그래프에서 다익스트라 알고리즘을 수행할 때, 최대 몇 번의 거리 갱신 연산이 발생할 수 있는가?', '3', '1.10번;2.16번;3.20번;4.25번', 17),

    (176, 'SELECT_DESCRIPTION', '정점의 개수가 V, 간선의 개수가 E일 때 우선순위 큐를 사용한 다익스트라 알고리즘의 시간복잡도는?', '2', '1.O(V²);2.O(E log V);3.O(V + E);4.O(E²)', 17),

    (177, 'SELECT_DESCRIPTION', '정점의 개수가 V, 간선의 개수가 E일 때 선형탐색(반복문)을 사용한 다익스트라 알고리즘의 시간복잡도는?', '1', '1.O(V²);2.O(E log V);3.O(V + E);4.O(E²)', 17),

    (178, 'SELECT_DESCRIPTION', '다익스트라 알고리즘이 음수 간선이 있는 그래프에서 올바르게 동작하지 않는 이유는?', '2', '1.우선순위 큐가 음수를 처리할 수 없어서;2.그리디 방식으로 한 번 방문한 노드를 재방문하지 않아서;3.메모리 부족 때문에;4.무한루프가 발생해서', 17),

    (179, 'SELECT_DESCRIPTION', '정점 5개, 간선 8개인 그래프에서 우선순위 큐(중복 허용)를 사용한 다익스트라 실행 시 우선순위 큐의 최대 크기는?', '2', '1.5;2.8;3.13;4.40', 17);

-- Unit13 - 벨먼-포드 알고리즘 (Lesson ID: 18)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (180, 'FILL_BLANK', '벨먼-포드 알고리즘과 다익스트라 알고리즘의 가장 중요한 차이점은?', '벨먼-포드는 음수 간선을 처리할 수 있다', '1.벨먼-포드는 음수 간선을 처리할 수 있다;2.벨먼-포드가 더 빠르다;3.다익스트라는 모든 간선을 확인한다;4.벨먼-포드는 우선순위 큐를 사용한다', 18),

    (181, 'SELECT_DESCRIPTION', 'V개의 정점과 E개의 간선을 갖고 있는 그래프에서 벨먼-포드 알고리즘의 시간복잡도는?', '1', '1.O(VE);2.O(V²);3.O(E log V);4.O(V + E)', 18),

    (182, 'SELECT_DESCRIPTION', 'V개의 정점을 갖고 있는 그래프에서 벨먼-포드 알고리즘은 최단 거리를 구하기 위해 모든 간선을 확인하는 과정을 몇 번 반복하는가?', '1', '1.V-1번;2.V번;3.V+1번;4.2V번', 18),

    (183, 'SELECT_DESCRIPTION', 'V개의 정점을 갖고 있는 그래프에서 벨먼-포드 알고리즘으로 음수 사이클을 감지하는 방법은?', '1', '1.V-1번 반복 후 추가로 한 번 더 실행했을 때 거리가 갱신되면;2.음수 간선의 개수를 센다;3.우선순위 큐가 비어있으면;4.거리 배열에 음수가 있으면', 18),

    (184, 'FILL_BLANK', '벨먼-포드 알고리즘은 매 단계마다 모든 _____를 확인하여 거리를 갱신한다.', '간선, edge', '-', 18),

    (185, 'SELECT_DESCRIPTION', '음수 사이클이 존재하는 그래프에서 벨먼-포드 알고리즘의 결과는?', '3', '1.정확한 최단 거리를 구할 수 있다;2.최단 거리를 무한히 줄일 수 있어 정확한 값을 보장할 수 없다;3.음수 사이클을 감지하고 이를 알려준다;4.알고리즘이 실행되지 않는다', 18);

-- CHapter 3
-- Unit14 - 네트워크 기초 (Lesson ID: 19)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (186, 'SELECT_DESCRIPTION', '다음 중 작은 지역(사무실, 건물) 내에서 컴퓨터와 장치를 연결하는 네트워크는?', '1', '1.LAN;2.WAN;3.MAN;4.인터넷', 19),

    (187, 'SELECT_DESCRIPTION', '클라이언트-서버 모델에서 ''클라이언트''의 역할은?', '1', '1.요청을 보내는 역할;2.요청을 처리하고 응답하는 역할;3.네트워크를 관리하는 역할;4.단순히 데이터를 전송하는 역할', 19),

    (188, 'SELECT_DESCRIPTION', '네트워크 토폴로지 중 중앙 장치에 모든 노드가 연결되는 구조는?', '2', '1.버스형;2.성형(Star);3.링형;4.메시형', 19),

    (189, 'SELECT_DESCRIPTION', '네트워크 성능을 측정하는 지표가 아닌 것은?', '4', '1.대역폭(Bandwidth);2.지연시간(Latency);3.처리량(Throughput);4.저장 용량(Storage)', 19),

    (190, 'FILL_BLANK', '데이터를 네트워크를 통해 목적지까지 정확하게 전달하기 위해 사용하는 규칙을 _____ 이라고 한다.', '프로토콜, protocol', '-', 19),

    (191, 'SELECT_DESCRIPTION', '양쪽 모두 데이터 전송이 가능하지만 한 번에 한쪽만 전송할 수 있는 통신 방식은?', '2', '1.단방향;2.반이중;3.전이중;4.양방향', 19),

    (192, 'FILL_BLANK', '데이터를 네트워크로 전송하기 위해 캡슐화된 최소 단위를 _____ 이라고 한다.', '패킷', '-', 19),

    (193, 'FILL_BLANK', '네트워크에서 단위 시간당 전송 가능한 최대 데이터 양을 나타내는 용어는 _____ 이다.', '대역폭, bandwidth', '-', 19),

    (194, 'SELECT_DESCRIPTION', '서로 다른 네트워크 간 통신을 가능하게 하는 논리적 주소는?', '1', '1.IP 주소;2.MAC 주소;3.서브넷;4.도메인 주소', 19),

    (195, 'FILL_BLANK', '데이터를 네트워크 내 특정 그룹의 장치들에게만 전달하는 전송 방식을 _____ 라고 한다.', '멀티캐스트', '-', 19),

    (196, 'SELECT_DESCRIPTION', '서로 다른 네트워크를 연결하고 최적 경로를 선택하는 장치는?', '1', '1.라우터;2.허브;3.스위치;4.모뎀', 19),

    (197, 'SELECT_DESCRIPTION', '데이터를 작은 단위로 나누어 전송하고 인터넷에서 주로 사용하는 방식은?', '2', '1.회선교환;2.패킷교환;3.전이중;4.반이중', 19);

-- Unit15 - OSI 7계층 (Lesson ID: 20)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (198, 'SELECT_DESCRIPTION', '비트 단위로 데이터를 전송하고 케이블, 광섬유, 무선 매체를 사용하는 계층은?', '1', '1.물리;2.데이터 링크;3.네트워크;4.전송', 20),

    (199, 'SELECT_DESCRIPTION', '데이터 전송 단위를 프레임(Frame)으로 처리하는 계층은?', '2', '1.전송;2.데이터 링크;3.네트워크;4.응용', 20),

    (200, 'FILL_BLANK', '전송 계층에서 부르는 데이터 전송 단위를 _____이라고 한다.', '세그먼트, segment', '-', 20),

    (201, 'SELECT_DESCRIPTION', '데이터링크 계층에서 장치를 고유하게 식별하는 주소는?', '2', '1.IP 주소;2.MAC 주소;3.포트 번호;4.서브넷 마스크', 20),

    (202, 'SELECT_DESCRIPTION', 'OSI 7계층에서 응용 계층의 역할은?', '2', '1.실제 데이터 전송;2.사용자와 네트워크 간 인터페이스 제공;3.패킷 라우팅;4.프레임 전송', 20),

    (203, 'SELECT_DESCRIPTION', 'TCP/IP 모델에서 전송 계층에 해당하는 프로토콜은?', '2', '1.IP;2.UDP;3.HTTP;4.ARP', 20),

    (204, 'FILL_BLANK', 'TCP/IP 모델에서 데이터 전송 시 응용 프로그램을 구분하기 위해 사용하는 것은 _____이다.', '포트번호', '-', 20),

    (205, 'FILL_BLANK', '주소 지정과 라우팅 기능을 수행하는 계층은_____계층 이다.', '네트워크', '-', 20),

    (206, 'SELECT_DESCRIPTION', '서로 다른 네트워크 간 데이터를 전달할 때 사용하고 네트워크 계층에서 사용되는 주소는 _____주소 이다.', 'ip', '-', 20),

    (207, 'SELECT_DESCRIPTION', 'TCP/IP에서 포트 번호 80번은 주로 어떤 서비스에 사용되는가?', '2', '1.SMTP;2.HTTP;3.FTP;4.DNS', 20),

    (208, 'FILL_BLANK', 'TCP/IP 모델에서 TCP는 데이터를 목적지까지 _____ 있게 전달하는 프로토콜이다.', '신뢰성', '-', 20);

-- Unit15 - TCP/IP 모델 (Lesson ID: 21)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (209, 'SELECT_DESCRIPTION', 'TCP/IP 모델의 인터넷 계층은 OSI 모델의 어느 계층과 대응되는가?', '3', '1.물리;2.데이터 링크;3.네트워크;4.전송', 21),

    (210, 'SELECT_DESCRIPTION', 'TCP/IP 모델 전송 계층의 주요 기능이 아닌 것은?', '3', '1.신뢰성 있는 데이터 전송;2.흐름 제어;3.패킷 라우팅;4.포트 번호 관리', 21),

    (211, 'FILL_BLANK', 'TCP/IP 모델의 응용 계층에서 도메인을 IP 주소로 변환하는 프로토콜은 _____이다.', 'dns', '-', 21),

    (212, 'FILL_BLANK', 'TCP/IP 모델에서 데이터가 목적지까지 전송될 때 사용하는 논리적 단위 _____이다.', '패킷', '-', 21),

    (213, 'SELECT_DESCRIPTION', '데이터링크 계층에서 충돌을 감지하고 제어하는 방식은 무엇인가?', '2', '1.DHCP;2.CSMA/CD;3.FTP;4.SMTP', 21),

    (214, 'SELECT_DESCRIPTION', 'TCP/IP에서 포트 번호 53번은 주로 어떤 서비스에 사용되는가?', '3', '1.HTTP;2.FTP;3.DNS;4.SMTP', 21),

    (215, 'FILL_BLANK', 'IP 주소를 자동으로 할당해주는 서버는 _____이다.', 'dhcp', '-', 21),

    (216, 'SELECT_DESCRIPTION', 'ARP(Address Resolution Protocol)의 기능은?', '1', '1.IP 주소를 MAC 주소로 변환;2.MAC 주소를 IP 주소로 변환;3.DNS 조회;4.DHCP 주소 할당', 21),

    (217, 'SELECT_DESCRIPTION', 'OSI 데이터링크 계층에서 오류 검출을 위해 추가하는 필드 이름은?', '2', '1.포트 번호;2.CRC;3.IP 주소;4.ACK', 21);

-- Unit16 - 물리 & 데이터 링크 계층 (Lesson ID: 22)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (218, 'FILL_BLANK', '물리 계층에서는 데이터를 _____ 단위로 전송한다.', '비트, bit', '-', 22),

    (219, 'SELECT_DESCRIPTION', 'UTP 케이블에서 데이터를 보내는 선의 쌍은 몇 개인가?', '2', '1.1쌍;2.2쌍;3.3쌍;4.4쌍', 22),

    (220, 'FILL_BLANK', '스위치가 프레임을 전달할 때 참조하는 주소는 _____이다.', 'mac 주소', '-', 22),

    (221, 'SELECT_DESCRIPTION', '광섬유 케이블의 장점이 아닌 것은?', '3', '1.장거리 전송 가능;2.전자기 간섭에 강함;3.설치가 매우 저렴함;4.높은 대역폭 제공', 22),

    (222, 'SELECT_DESCRIPTION', 'CSMA/CD에 대한 설명 중 틀린 것은 무엇인가', '4', '1.장치가 데이터를 보내기 전에 매체를 감시한다;2.충돌이 발생하면 즉시 감지하고 재전송한다;3.주로 유선 LAN에서 사용된다;4.무선 LAN에서 충돌을 회피하기 위해 사용된다', 22),

    (223, 'FILL_BLANK', '전송 매체에서 신호가 약해지는 현상을 _____라 한다.', '감쇠', '-', 22),

    (224, 'SELECT_DESCRIPTION', 'CRC 방식의 특징으로 올바른 것은?', '2', '1.단일 비트 오류만 검출 가능하다;2.연속된 다중 비트 오류도 검출 가능하다;3.데이터 암호화 방식이다;4.충돌 회피 기능을 제공한다', 22),

    (225, 'SELECT_DESCRIPTION', 'CSMA/CA 방식은 주로 _____ LAN에서 사용된다.', '무선', '-', 22),

    (226, 'SELECT_DESCRIPTION', '전송 매체 중 전자기 간섭(EMI)에 가장 취약한 것은?', '2', '1.동축 케이블;2.UTP 케이블;3.광섬유;4.무선', 22),

    (227, 'FILL_BLANK', '이더넷에서 최소 프레임 크기는 _____바이트이다.', '64', '-', 22),

    (228, 'SELECT_DESCRIPTION', '스위치와 허브의 차이점으로 옳은 것은?', '3', '1.스위치는 모든 포트로 브로드캐스트한다;2.허브는 MAC 주소 기반으로 프레임을 전달한다;3.스위치는 MAC 주소 기반으로 프레임을 전달한다;4.허브는 IP 주소 기반으로 라우팅한다', 22);

-- Unit17 - 네트워크 계층 (Lesson ID: 23)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (229, 'FILL_BLANK', 'IPv4 주소는 _____비트로 구성되어 있다.', '32', '-', 23),

    (230, 'SELECT_DESCRIPTION', 'IPv6 주소 길이는 얼마인가?', '3', '1.32비트;2.64비트;3.128비트;4.256비트', 23),

    (231, 'SELECT_DESCRIPTION', 'IPv4 주소 클래스 중 일반적으로 소규모 네트워크에서 사용되는 클래스는?', '3', '1.클래스 A;2.클래스 B;3.클래스 C;4.클래스 D', 23),

    (232, 'FILL_BLANK', 'IP 주소에서 같은 네트워크 내 모든 장치로 전송하는 주소는?', '브로드캐스트', '1.브로드캐스트;2.멀티캐스트;3.유니캐스트;4.애니캐스트', 23),

    (233, 'SELECT_DESCRIPTION', '서브넷팅의 목적이 아닌 것은?', '3', '1.트래픽 분리;2.IP 주소 효율적 사용;3.데이터 암호화;4.네트워크 관리 용이', 23),

    (234, 'FILL_BLANK', '서브넷 마스크는 네트워크 주소와 _____ 주소를 구분하기 위해 사용된다.', '호스트', '-', 23),

    (235, 'SELECT_DESCRIPTION', '호스트 수 계산 공식으로 옳은 것은?', '2', '1.2^(32-서브넷 비트);2.2^(32-서브넷 비트)-2;3.2^(서브넷 비트);4.2^(서브넷 비트)-2', 23),

    (236, 'FILL_BLANK', '라우팅 테이블에는 목적지 IP, 서브넷 마스크, 게이트웨이, _____ 등이 포함된다.', '인터페이스', '-', 23),

    (237, 'SELECT_DESCRIPTION', '정적 라우팅의 특징은 무엇인가?', '2', '1.라우터가 자동으로 경로를 갱신한다;2.관리자가 수동으로 경로를 설정한다;3.트래픽에 따라 경로가 변동한다;4.동적 라우팅 프로토콜을 사용한다', 23),

    (238, 'SELECT_DESCRIPTION', '정적 라우팅은 주로 네트워크가 _____ 환경에서 사용된다', '1', '1.작거나 단순한;2.크거나 단순한;3.크거나 복잡한;4.작거나 복잡한', 23),

    (239, 'SELECT_DESCRIPTION', '동적 라우팅 프로토콜 중 내부 게이트웨이 프로토콜(IGP)이 아닌 것은?', '3', '1.RIP;2.OSPF;3.BGP;4.EIGRP', 23),

    (240, 'FILL_BLANK', '라우터가 목적지 IP와 가장 구체적인 서브넷을 매칭하여 선택하는 경로를 _____ 경로라고 한다.', '최적', '-', 23);

-- Unit18 - 전송 계층 (Lesson ID: 24)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (241, 'SELECT_DESCRIPTION', 'UDP의 주요 장점으로 올바른 것은?', '2', '1.신뢰성 보장;2.낮은 지연과 오버헤드;3.순서 제어;4.흐름 제어', 24),

    (242, 'SELECT_DESCRIPTION', 'TCP 헤더에 포함되지 않는 필드는?', '4', '1.시퀀스 번호;2.체크섬;3.포트번호;4.MAC 주소', 24),

    (243, 'FILL_BLANK', 'TCP의 흐름 제어는 _____ 윈도우 방식을 사용한다.', '슬라이딩', '-', 24),

    (244, 'FILL_BLANK', 'TCP 연결을 설정할 때 사용하는 3단계 과정은 _____ 연결(handshake)이다.', '3-way', '-', 24),

    (245, 'FILL_BLANK', 'TCP는 데이터가 순서대로 도착하도록 _____ 기능을 제공한다.', '순서 제어', '-', 24),

    (246, 'SELECT_DESCRIPTION', '3-way 핸드쉐이크 과정에서 순서가 올바른 것은?', '1', '1.SYN → SYN-ACK → ACK;2.ACK → SYN → SYN-ACK;3.SYN-ACK → SYN → ACK;4.SYN → ACK → SYN-ACK', 24),

    (247, 'SELECT_DESCRIPTION', 'TCP 헤더의 ACK 번호 필드는 무엇을 나타내는가?', '1', '1.수신 측이 다음에 받을 바이트 번호;2.송신 측이 보낸 패킷의 순서 번호;3.패킷의 포트번호;4.체크섬 값', 24),

    (248, 'SELECT_DESCRIPTION', 'TCP 흐름제어의 주요 목적은 무엇인가?', '2', '1.네트워크 대역폭 확보;2.수신 측 버퍼 오버플로우 방지;3.포트번호 충돌 방지;4.데이터 암호화', 24),

    (249, 'FILL_BLANK', '4-way 핸드쉐이크에서 ACK 수신 후에도 일정 시간 동안 연결을 유지하는 상태를 _____라고 한다.', 'time-wait', '-', 24),

    (250, 'SELECT_DESCRIPTION', 'TCP 혼잡 제어의 주요 목적은 무엇인가?', '2', '1.수신 측 버퍼 오버플로우 방지;2.네트워크 혼잡으로 인한 패킷 손실 방지;3.포트번호 관리;4.데이터 암호화', 24),

    (251, 'SELECT_DESCRIPTION', 'UDP는 주로 어떤 상황에서 사용되는가?', '2', '1.파일 전송과 이메일;2.실시간 비디오 스트리밍과 온라인 게임;3.HTTP 웹 브라우징;4.TCP 기반 데이터베이스 동기화', 24);

-- Unit19 - 응용 계층 (Lesson ID: 25)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (252, 'SELECT_DESCRIPTION', 'HTTPS는 HTTP에 무엇을 추가하여 보안을 강화했는가?', '2', '1.TCP 연결;2.SSL/TLS 암호화;3.UDP 전송;4.DNS 변환', 25),

    (253, 'SELECT_DESCRIPTION', 'SMTP의 주된 용도는 무엇인가?', '2', '1.웹 페이지 전송;2.이메일 송신;3.이메일 수신;4.파일 다운로드', 25),

    (254, 'SELECT_DESCRIPTION', 'POP3와 IMAP은 주로 어떤 기능과 관련이 있는가', '2', '1.웹 페이지 전송;2.이메일 수신;3.이메일 송신;4.파일 전송', 25),

    (255, 'SELECT_DESCRIPTION', 'FTP는 주로 어떤 목적으로 사용되는가?', '2', '1.웹 페이지 요청;2.파일 전송;3.이메일 송수신;4.도메인 이름 변환', 25),

    (256, 'SELECT_DESCRIPTION', 'SMTP의 기본 포트번호는 무엇인가?', '2', '1.21;2.25;3.53;4.80', 25),

    (257, 'FILL_BLANK', 'FTP에서 데이터 전송 시 사용하는 두 가지 채널은 제어 채널(Control Channel)과 _____ 채널이다.', '데이터', '-', 25),

    (258, 'SELECT_DESCRIPTION', 'POP3와 IMAP의 차이점은?', '1', '1.IMAP은 서버에 이메일을 남기고 동기화, POP3는 다운로드 후 삭제;2.POP3는 서버에 이메일을 남기고 동기화, IMAP은 다운로드 후 삭제;3.둘 모두 동일;4.IMAP은 웹 전송, POP3는 파일 전송', 25),

    (259, 'SELECT_DESCRIPTION', 'FTP에서 사용하는 두 채널은?', '2', '1.명령 채널과 데이터 채널;2.제어 채널과 데이터 채널;3.제어 채널과 인증 채널;4.명령 채널과 인증 채널', 25),

    (260, 'SELECT_DESCRIPTION', 'HTTP/1.1에서 Keep-Alive 기능의 목적은 무엇인가?', '1', '1.연결을 계속 열어 여러 요청을 처리;2.IP 주소를 변경;3.웹 페이지 캐시 삭제;4.클라이언트 인증', 25),

    (261, 'SELECT_DESCRIPTION', 'HTTPS가 HTTP보다 안전한 이유는?', '2', '1.TCP 연결 사용;2.데이터 암호화와 무결성 검증;3.포트번호 변경;4.DNS 변환 수행', 25),

    (262, 'SELECT_DESCRIPTION', 'DNS 레코드 중 IP 주소를 나타내는 레코드는 무엇인가?', '2', '1.MX;2.A;3.CNAME;4.TXT', 25),

    (263, 'SELECT_DESCRIPTION', 'FTP의 제어 채널과 데이터 채널의 차이점으로 올바른 것은?', '1', '1.제어 채널은 명령 전송, 데이터 채널은 파일 전송;2.제어 채널은 파일 전송, 데이터 채널은 명령 전송;3.둘 다 파일 전송만 수행;4.둘 다 명령 전송만 수행', 25);

-- Unit20 - 네트워크 보안 (Lesson ID: 26)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (264, 'SELECT_DESCRIPTION', 'SSL/TLS의 주요 목적은?', '2', '1.TCP 연결;2.데이터 암호화 및 무결성;3.포트 관리;4.파일 전송', 26),

    (265, 'SELECT_DESCRIPTION', 'VPN의 주된 목적은?', '2', '1.이메일 송신;2.안전한 터널링과 암호화;3.DNS 조회;4.포트 필터링', 26),

    (266, 'FILL_BLANK', '방화벽은 불법 접근을 차단하여 _____을 제공한다.', '보안', '-', 26),

    (267, 'SELECT_DESCRIPTION', 'MITM 공격의 특징은?', '1', '1.데이터 도청/변조;2.서비스 거부;3.포트 스캐닝;4.이메일 송신', 26),

    (268, 'SELECT_DESCRIPTION', 'DoS 공격의 목적은?', '2', '1.데이터 암호화;2.자원 소진으로 서비스 중단;3.이메일 수신;4.DNS 조회', 26),

    (269, 'FILL_BLANK', '피싱 공격은 사용자의 _____을 탈취하려는 공격이다.', '정보', '-', 26),

    (270, 'SELECT_DESCRIPTION', 'PKI에서 인증서와 공개키를 통해 보장하는 것은?', '1', '1.신뢰성;2.포트관리;3.캐시 관리;4.연결 유지', 26),

    (271, 'SELECT_DESCRIPTION', 'ACL의 주요 역할은?', '1', '1.접근 권한 제어;2.이메일 송신;3.파일 다운로드;4.DNS 변환', 26),

    (272, 'SELECT_DESCRIPTION', 'SSH의 주요 목적은?', '1', '1.원격 접속 보안;2.파일 다운로드;3.이메일 송신;4.DNS 조회', 26),

    (273, 'FILL_BLANK', '암호화 방식 중 공개키와 개인키를 사용하는 방식은 _____ 암호화이다.', '비대칭', '-', 26),

    (274, 'SELECT_DESCRIPTION', '대칭키 암호화의 장점은?', '1', '1.속도가 빠르다;2.키 관리 간단;3.인증서 필요;4.공개키 필요', 26),

    (275, 'SELECT_DESCRIPTION', 'DoS와 DDoS 공격의 차이는?', '1', '1.DDoS는 여러 컴퓨터에서 공격;2.DoS는 여러 컴퓨터에서 공격;3.둘 다 동일;4.DDoS는 이메일 공격', 26),

    (276, 'FILL_BLANK', '디지털 서명은 데이터의 _____와 송신자 신원을 확인하는 데 사용된다.', '무결성', '-', 26);

-- Chapter 4
-- Unit21 - 운영체제 & 시스템 구조 1 (Lesson ID: 27)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (277, 'FILL_BLANK', '시스템 콜(System Call)이 실행될 때 CPU 모드는 _____로 전환된다.', '커널, kernel', '-', 27),

    (278, 'FILL_BLANK', 'BIOS 이후에 실행되어 운영체제를 메모리에 적재하는 프로그램은 _____이다.', '부트로더, bootloader', '-', 27),

    (279, 'SELECT_DESCRIPTION', 'UNIX 계열의 운영체제가 아닌 것은?', '3', '1.Linux;2.macOS;3.Window;4.Android', 27),

    (280, 'FILL_BLANK', 'CPU에서 명령어 해석 역할을 하는 구성 요소는 _____이다.', '디코더, decoder', '-', 27),

    (281, 'SELECT_DESCRIPTION', '저장공간의 접근 속도가 높은 순서대로 올바르게 나열된 것은?', '4', '1.Tape Drive > Hard Drive > RAM > SSD;2.Hard Drive > SSD > Tape Drive > RAM;3.Tape Drive > Hard Drive > SSD > RAM;4.RAM > SSD > Hard Drive > Tape Drive', 27),

    (282, 'SELECT_DESCRIPTION', '다음 중 CPU에 가장 가까운 것은?', '1', '1.L1;2.L2;3.모두 동일함', 27),

    (283, 'FILL_BLANK', '64KB 메모리의 주소는 _____부터 _____까지다.', '0, 65535', '1.0, 65535;2.1, 65536;3.0, 255;4.1, 256', 27),

    (284, 'SELECT_DESCRIPTION', '디바이스가 CPU를 거치지 않고 메모리와 직접 데이터를 주고받을 수 있는 방식은?', 'dma, direct memory access', '-', 27),

    (285, 'FILL_BLANK', 'DMA는 데이터 전송이 완료되면 CPU에 _____를 보내어 전송이 끝났음을 알린다.', '인터럽트, interrupts', '-', 27),

    (286, 'SELECT_DESCRIPTION', '인터럽트의 장점으로 옳지 않은 것은?', '3', '1.CPU와 디바이스 병렬 동작;2.I/O 대기 중 다른 작업 수행;3.모든 인터럽트는 동기적 발생;4.핸들러 후 원래 프로세스 복귀', 27),

    (287, 'SELECT_DESCRIPTION', 'BIOS의 주요 역할로 옳지 않은 것은?', '4', '1.하드웨어 정상 여부 확인;2.저장장치의 MBR을 메모리에 적재;3.저수준 장치 드라이버 설치;4.프로세스 스케줄링 수행', 27),

    (288, 'FILL_BLANK', '_____는 BIOS의 설정 값을 저장한다.', '시모스, cmos', '-', 27);

-- Unit21 - 운영체제 & 시스템 구조 2 (Lesson ID: 28)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (289, 'FILL_BLANK', 'x86 아키텍처에서 시스템 콜은 int _____명령을 통해 발생한다.', '0x80', '-', 28),

    (290, 'FILL_BLANK', '사용자 모드에서 실행되는 프로그램이 시스템 콜을 호출하면 CPU 모드는 _____모드로 변환된다.', '커널, kernel', '-', 28),

    (291, 'FILL_BLANK', '파일 입출력, 프로세스 제어, 메모리 관리 등이 _____을 통해 수행된다.', '시스템 콜, 시스템콜, system call', '-', 28),

    (292, 'FILL_BLANK', '커널 아키텍처 중 _____커널은 모든 기능을 커널 공간에서 실행하며, 코드 베이스가 크고 기능이 많다. 반면 _____커널은 최소한의 기능만 커널에 포함시키고 나머지는 사용자 공간에서 실행한다.', 'monolithic, microkernel', '1.Monolithic, Microkernel;2.Microkernel, Hybrid kernel;3.Hybrid, Monolithic;4.Microkernel, Monolithic', 28),

    (293, 'SELECT_DESCRIPTION', '다음 운영체제와 커널 구조를 올바르게 연결한 것은?', '2', '1.Linux - Microkernel;2.ios - Hybrid Kernel;3.Android - Microkernel;4.QNX - Monolithic Kernel', 28),

    (294, 'SELECT_DESCRIPTION', '마이크로커널 구조에서 커널 공간에 포함되는 필수 기능으로 올바른 것은?', '3', '1.File System;2.Disk Driver;3.CPU Scheduling;4.Networking Service', 28),

    (295, 'FILL_BLANK', '마이크로커널은 많은 컨텍스트 스위치로 성능이 _____된다.', '저하', '-', 28),

    (296, 'FILL_BLANK', '모놀리식 커널은 _____ 코드 베이스로 커널 개발이 용이하다.', '단일, 싱글, single', '-', 28),

    (297, 'SELECT_DESCRIPTION', 'MBR(Master Boot Record)의 크기로 옳은 것은?', '1', '1.512byte;2.512bit;3.256byte;4.128byte', 28),

    (298, 'SELECT_DESCRIPTION', 'CPU 캐시 계층 중 가장 빠르고 용량이 작은 것은?', '1', '1.L1;2.L2;3.L3;4.모두 동일함', 28),

    (299, 'FILL_BLANK', '운영체제는 사용자에게 실제보다 많은 CPU나 메모리가 있는 것처럼 보이게 하는데, 이를 _____라고 한다.', '가상화', '-', 28),

    (300, 'SELECT_DESCRIPTION', '운영체제의 설계 목표 중 하나로, 프로그램 간 간섭을 막고 안정성을 보장하는 것은?', '보호', '-', 28);

-- Unit21 - 운영체제 & 시스템 구조 3 (Lesson ID: 29)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (301, 'SELECT_DESCRIPTION', '초기 컴퓨터 시스템의 운영 방식으로, 작업을 순서대로 모아 처리하는 것은?', '2', '1.시분할 시스템;2.배치 처리 시스템;3.멀티태스킹 시스템;4.실시간 시스템', 29),

    (302, 'FILL_BLANK', '운영체제는 프로그램이 I/O 장치를 직접 다루지 않고 사용할 수 있도록 _____를 제공한다', '장치 드라이버', '-', 29),

    (303, 'FILL_BLANK', '현대 운영체제의 중요한 목표 중 하나는, 시스템 일부가 고장나도 계속 동작하는 _____을 보장하는 것이다.', '신뢰성', '-', 29),

    (304, 'SELECT_DESCRIPTION', '다수의 사용자와 다수의 프로그램이 동시에 시스템을 사용하는 것을 가능하게 한 것은?', '시분할, time-sharing, time sharing', '-', 29),

    (305, 'SELECT_DESCRIPTION', '멀티프로그래밍이 도입된 주요 목적은?', '1', '1.CPU 활용률 향상;2.코드 가독성 향상;3.기계어 단순화;4.보안 취약점 제거', 29),

    (306, 'SELECT_DESCRIPTION', '운영체제의 설계 목표에 해당하지 않는 것은?', '4', '1.추상화 제공;2.성능 향상;3.보호와 보안;4.하드웨어 복잡도 증가', 29),

    (307, 'SELECT_DESCRIPTION', '시분할(Time-sharing) 시스템의 주요 장점은?', '2', '1.전체 시스템 처리량 최대화;2.대화식 사용자의 빠른 응답 시간 제공;3.메모리 사용량 최소화;4.네트워크 대역폭 절약', 29),

    (308, 'FILL_BLANK', '운영체제가 제공하는 핵심 기능 중 하나는 하드웨어 세부사항을 감추고 _____ 인터페이스를 제공하는 것이다.', '추상화', '-', 29);

-- Unit22 - 프로세스 1 (Lesson ID: 30)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (309, 'FILL_BLANK', '프로그램은 디스크에 저장된 명령어와 데이터의 묶음이고, 실행 중인 프로그램을 _____라 한다.', '프로세스', '-', 30),

    (310, 'SELECT_DESCRIPTION', '다음 중 프로세스 상태가 아닌 것은?', '4', '1.Running;2.Ready;3.Waiting;4.Request', 30),

    (311, 'FILL_BLANK', '실행 중인 프로세스를 다른 프로세스로 전환하기 위해 레지스터 상태를 저장하고 복원하는 과정을 _____라고 한다.', '문맥 교환, context switch, 컨텍스트 스위치', '-', 30),

    (312, 'FILL_BLANK', 'CPU가 한 프로세스를 실행하다가 다른 프로세스로 전환될 때, 이전 프로세스의 상태는 _____에 저장된다', 'pcb, process control block', '-', 30),

    (313, 'SELECT_DESCRIPTION', '다음 중 PCB에 포함되지 않는 정보는?', '4', '1.프로세스 상태;2.레지스터 값;3.프로그램 카운터;4.컴파일러 최적화 정보', 30),

    (314, 'FILL_BLANK', '프로세스가 실행할 준비는 되었으나 CPU를 할당받지 못한 상태를 _____라고 한다.', '준비, ready', '-', 30),

    (315, 'SELECT_DESCRIPTION', '부모 프로세스가 먼저 종료했지만 자식 프로세스가 계속 실행 중인 경우, 자식 프로세스는 어떤 상태가 되는가?', '2', '1.zombie;2.orphan;3.ready;4.terminated', 30),

    (316, 'FILL_BLANK', '프로세스가 I/O 요청을 하여 기다리는 동안의 상태는 _____이다.', '대기, waiting', '-', 30),

    (317, 'FILL_BLANK', '자식 프로세스의 종료를 부모 프로세스가 확인하는 시스템 콜은?', 'wait()', '-', 30),

    (318, 'SELECT_DESCRIPTION', '이중 동작 모드(Dual-Mode Operation)에서 일반 사용자 프로그램이 동작하는 모드는?', '1', '1.User Mode;2.Kernel Mode;3.Supervisor Mode;4.Hypervisor Mode', 30),

    (319, 'FILL_BLANK', '자식 프로세스가 종료되었지만 부모 프로세스가 아직 _____ 시스템 콜을 호출하지 않으면 자식은 _____ 상태가 된다.', 'wait, zombie', '1.wait, orphan;2.wait, zombie;3.fork, ready;4.kill, zombie', 30),

    (320, 'SELECT_DESCRIPTION', '프로세스의 하드웨어 상태 중 현재 실행 중인 명령어의 위치를 가리키는 레지스터는?', '프로그램 카운터, pc, program counter', '-', 30);

-- Unit22 - 프로세스 2 (Lesson ID: 31)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (321, 'SELECT_DESCRIPTION', '우선순위가 가장 높은 프로세스가 준비 상태에서 실행 상태로 전환되는 것은?', '3', '1.Wake Up;2.Timer Runout;3.Dispatch;4.Spooling', 31),

    (322, 'SELECT_DESCRIPTION', '프로세스 관리 명령어 중 현재 실행 중인 프로세스를 확인하는 명령어는?', 'ps', '-', 31),

    (323, 'SELECT_DESCRIPTION', '모든 프로세스 트리의 루트가 되며 커널에 의해 가장 먼저 시작되는 프로세스는?', 'init', '-', 31),

    (324, 'SELECT_DESCRIPTION', 'x86에서 스택의 성장 방향은?', '2', '1.위로;2.아래로;3.고정;4.OS에 따라 다름', 31),

    (325, 'SELECT_DESCRIPTION', '함수 종료 시 ret 명령은 스택에서 무엇을 꺼내나?', '2', '1.인자;2.복귀 주소;3.지역 변수;4.레지스터', 31),

    (326, 'SELECT_DESCRIPTION', '함수 호출 시 새 스택 프레임이 생성될 때 가장 먼저 수행되는 동작은?', '1', '1.EBP 저장;2.ESP 증가;3.EAX 초기화;4.PC 변경', 31),

    (327, 'SELECT_DESCRIPTION', '운영체제가 새로운 프로세스를 시작할 때 가짜 스택 프레임을 만드는 이유는 무엇인가?', '4', '1.다른 프로세스와 데이터 공유 목적;2.실행 속도 향상;3.PID 재사용 목적;4.switch()를 호출한 것처럼 보이기 위해', 31),

    (328, 'SELECT_DESCRIPTION', '운영체제가 프로세스를 전환하는 시점으로 옳지 않은 것은?', '4', '1.프로세스가 I/O 요청을 할 때;2.CPU 사용 시간이 끝났을 때;3.프로세스가 스스로 CPU를 양보할 때;4.프로세스가 정상적으로 종료될 때', 31),

    (329, 'FILL_BLANK', '운영체제가 사용자 프로세스와 커널을 분리하지 않고 모두 같은 권한으로 실행한다면, 사용자 프로세스가 _____를 덮어쓸 수 있다.', '커널 메모리', '-', 31),

    (330, 'FILL_BLANK', 'x86 CPU는 권한 링(RIng) 구조를 제공한다. 대부분의 OS는 Ring 0과 Ring _____만 사용한다.', '0, 3', '-', 31),

    (331, 'SELECT_DESCRIPTION', '다음은 시스템 콜이 실행되는 과정을 단계별로 설명한 것이다. 올바른 순서를 나열한 것은? a. OS가 시스템 콜을 실행하고 결과를 EAX에 저장한다. b. 소프트웨어가 int 0x80을 실행한다. c. CPU가 OS 핸들러로 제어를 넘기고, 링 3에서 링 0으로 전환한다. d. OS가 프로세스 상태를 복원하고, iret으로 사용자 모드로 복귀한다.', '2', '1.a-b-c-d;2.b-c-a-d;3.b-a-c-d;4.c-b-a-d', 31),

    (332, 'SELECT_DESCRIPTION', '다음 중 UNIX에서 fork()를 호출할 때 **실제로 수행되는 단계**로 옳지 않은 것은?', '3', '1.새로운 PCB를 생성하고 초기화;2.새로운 주소 공간 생성;3.부모 프로세스의 커널 복사;4.부모 프로세스의 실행 상환경을 상속 받는다.', 31);

-- Unit23 - 스레드 (Lesson ID: 32)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (333, 'FILL_BLANK', '모든 프로세스는 적어도 하나의 _____를 가진다.', '스레드', '-', 32),

    (334, 'SELECT_DESCRIPTION', '다중 스레드 프로세스에서 스레드 간에 공유되지 않는 것은?', '3', '1.코드;2.전역 데이터;3.스택;4.파일 디스크립터', 32),

    (335, 'FILL_BLANK', '_____ 모델은 여러 사용자 스레드를 여러 커널 스레드에 매핑할 수 있다.', 'many-to-many', '-', 32),

    (336, 'SELECT_DESCRIPTION', 'Many-to-One 스레드 모델의 단점으로 옳은 것은?', '3', '1.각 사용자 스레드가 커널 스레드와 1:1로 매핑된다.;2.멀티코어 시스템에서 병렬 실행이 가능하다.;3.하나의 스레드가 블록되면 모든 스레드가 블록된다.;4.운영체제가 충분한 커널 스레드를 생성할 수 있다.', 32),

    (337, 'SELECT_DESCRIPTION', 'Two-level 스레드 모델이 Many-to-Many 모델과의 차이점으로 옳은 것은?', '4', '1.하나의 커널 스레드만 사용;2.생성 시 커널 스레드 자동 생성;3.병렬 실행 불가;4.특정 스레드 바인딩 가능', 32),

    (338, 'FILL_BLANK', 'Pthread에서 스레드를 생성하는 함수는 _____이다.', 'pthread_create()', '-', 32),

    (339, 'FILL_BLANK', 'pthread_join(tid, 0)의 역할은 무엇인가? (pthread_t tid;)', '특정 스레드 종료까지 대기', '1.특정 스레드 종료까지 대기;2.현재 스레드 즉시 종료;3.스레드 속성 초기화;4.새 스레드 생성', 32),

    (340, 'FILL_BLANK', 'clone() API는 부모 프로세스의 주소 공간을 공유하지만 _____은 새로 할당받는다.', '스택, stack', '-', 32),

    (341, 'SELECT_DESCRIPTION', '예를 들어 10개의 스레드를 가지고 있다고 하자. 한 스레드가 exec()를 호출하면 어떤 일이 벌어지는가?', '2', '1.하나를 제외한 모든 스레드 종료;2.모든 스레드 종료;3.하나의 스레드 종료;4.새로운 스레드 생성', 32),

    (342, 'FILL_BLANK', 'TLS는 전역 변수처럼 보이지만 모든 스레드가 공유하는 것이 아니라 _____마다 별도로 존재한다.', '스레드, thread', '-', 32),

    (343, 'SELECT_DESCRIPTION', '실시간 주식 거래 시스템에서 성능보다는 안정성이 중요한 경우, 스레드 대신 프로세스를 선택한다. 스레드를 선택하지 않는 이유는?', '2', '1.생성 비용이 크다.;2.오류가 전체 시스템에 전파된다.;3.메모리 사용량이 많다.;4.동시 실행이 불가능하다.', 32),

    (344, 'SELECT_DESCRIPTION', '어떤 API를 사용해야 새로운 프로세스가 부모와 완전히 독립적인 주소 공간을 갖는가?', '1', '1.fork();2.clone();3.exec();4.pthread_create()', 32),

    (345, 'SELECT_DESCRIPTION', '다중 코어 CPU에서 병렬 실행이 불가능한 모델은?', '1', '1.Many-To-One;2.One-To-One;3.Many-To-Many;4.Two-level', 32),

    (346, 'SELECT_DESCRIPTION', '보안성이 중요한 금융 애플리케이션에서 전역 데이터가 스레드마다 독립적으로 유지되도록 하기 위해 사용하는 기법은?', '2', '1.Context Switching;2.TLS;3.Process Isolation;4.OpenMP', 32);

-- Unit24 - 스케줄링 1 (Lesson ID: 33)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (347, 'SELECT_DESCRIPTION', '스케줄러가 스케줄링 결정을 내리는 시점 중 선점(preemption)이 발생하는 경우는?', '3', '1.running → waiting;2.프로세스 종료;3.running → ready;4.waiting → terminated', 33),

    (348, 'SELECT_DESCRIPTION', 'Dispatch Latency가 큰 경우 시스템에 미치는 주요 영향은?', '2', '1.CPU 사용률이 높아진다.;2.응답 시간이 느려진다.;3.보안성이 강화된다.;4.프로세스 동기화가 단순해진다.', 33),

    (349, 'FILL_BLANK', '스케줄러가 다음에 실행할 프로세스를 선택하면, 디스패처는 실제로 _____를 수행하여 선택된 프로세스에게 CPU 제어권을 넘겨준다.', '컨텍스트 스위칭, context switching', '-', 33),

    (350, 'FILL_BLANK', '시스템 컨텐션 스코프(SCS)는 커널이 _____를 직접 지원할 때 적용되는 스케줄링 범위이다.', '스레드, thread', '-', 33),

    (351, 'SELECT_DESCRIPTION', '커널이 스레드를 지원하지 않는 환경에서 스레드 스케줄링은 어떻게 이루어지는가?', '1', '1.각 프로세스가 자체적으로 스레드 스케줄링 수행;2.스레드 라이브러리가 모든 스케줄링 담당;3.디스패처가 스레드를 생성;4.스케줄링이 불가능하다.', 33),

    (352, 'FILL_BLANK', '스케줄러가 고려해야 할 주요 최적화 기준에는 CPU 사용률, 처리량, 대기 시간, 응답 시간, _____이 있다.', '공정성, fairness', '-', 33),

    (353, 'SELECT_DESCRIPTION', '모든 최적화 기준을 동시에 만족할 수 없는 이유로 가장 적절한 것은?', '3', '1.CPU 자원이 무한하지 않기 때문에;2.I/O 장치가 속도가 느리기 때문에;3.각 기준이 서로 상충 관계에 있기 때문에;4.커널이 프로세스를 지원하지 않기 때문에', 33),

    (354, 'FILL_BLANK', '_____ 스케줄링은 프로세스가 자발적으로 CPU를 반납하기 전까지 CPU를 계속 점유할 수 있고, _____ 스케줄링은 스케줄러가 강제로 CPU를 회수하여 다른 프로세스에게 할당할 수 있다.', '비선점형, 선점형', '-', 33),

    (355, 'SELECT_DESCRIPTION', '프로세스가 시스템에 도착한 시점부터 완전히 실행을 마칠 때까지의 총 소요 시간은?', 'turnaround time', '-', 33),

    (356, 'FILL_BLANK', '프로세스가 실행하는 작업들의 집합을 _____라 하며, 스케줄링 성능을 평가할 때 중요한 기준이 된다.', '워크로드, workload', '-', 33);

-- Unit24 - 스케줄링 2 (Lesson ID: 34)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (357, 'SELECT_DESCRIPTION', 'CPU burst 시간이 긴 프로세스가 먼저 실행될 때 짧은 프로세스들이 오랫동안 대기하게 되는 현상을 무엇이라고 하는가?', '2', '1.Head-of-line blocking;2.Convoy effect;3.Starvation;4.Priority inversion', 34),

    (358, 'FILL_BLANK', 'SJF 스케줄링 알고리즘은 평균 _____ 시간을 최소화하는 최적 알고리즘으로 알려져 있다.', '대기, waiting', '-', 34),

    (359, 'SELECT_DESCRIPTION', 'STCF 스케줄러의 특징으로 옳은 것은?', '2', '1.프로세스가 시작하면 끝날 때까지 CPU를 독점한다.;2.남은 실행 시간이 가장 짧은 프로세스를 선택한다.;3.FCFS보다 평균 대기 시간이 항상 길다.;4.I/O bound 프로세스에는 적합하지 않다.', 34),

    (360, 'FILL_BLANK', 'SJF와 STCF 모두 각 프로세스의 CPU _____ Time을 미리 알고 있다는 가정 하에 동작한다.', 'burst', '-', 34),

    (361, 'FILL_BLANK', 'SJF에 선점 기능을 추가한 스케줄러를 _____라 한다.', 'stcf, shortest time-to-completion first', '-', 34),

    (362, 'FILL_BLANK', 'Interactive 시스템에서 가장 중요한 성능 지표는 _____이다.', '응답성, responsiveness', '-', 34),

    (363, 'FILL_BLANK', 'Response time은 _____ Run Time - Arrival time 으로 정의된다.', 'first', '-', 34),

    (364, 'FILL_BLANK', 'Round Robin 스케줄링에서 time slice를 너무 작게 설정했을 때 _____ 현상이 일어날 수 있다.', '오버헤드, overhead', '-', 34);

-- Unit24 - 스케줄링 3 (Lesson ID: 35)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (365, 'SELECT_DESCRIPTION', '우선순위 스케줄링에서 기아(Starvation) 문제를 완화하기 위한 대표적인 방법은?', '2', '1.고정된 CPU burst 시간 사용;2.우선순위를 동적으로 조정하는 방법;3.더 긴 프로세스를 우선 실행;4.FIFO 큐 사용', 35),

    (366, 'FILL_BLANK', 'EDF(Earliest Deadline First) 스케줄링은 _____이 빠를수록 더 높은 우선순위를 가진다.', 'deadline, 마감기한', '-', 35),

    (367, 'FILL_BLANK', 'MLQ(Multilevel Queue) 스케줄링에서 사용자 상호작용 프로세스는 _____ 방식으로 스케줄링되고, CPU bound 프로세스는 FCFS 방식으로 스케줄링된다.', 'rr, round robin, 라운드로빈', '-', 35),

    (368, 'FILL_BLANK', 'MLFQ에서 한 프로세스가 time slice를 끝까지 다 사용하면 우선순위가 _____진다.', '낮아', '-', 35),

    (369, 'SELECT_DESCRIPTION', '다음 중 옳지 않은 MLFQ 규칙은?', '1', '1.우선순위가 같다면 반드시 FCFS 방식을 사용한다.;2.제일 높은 우선순위를 가진 프로세스 먼저 실행한다.;3.time slice를 다 쓴 프로세스는 우선순위를 낮춘다.;4.time slice를 다 쓰기 전에 종료하면 현재 큐에 머무른다.', 35),

    (370, 'FILL_BLANK', '높은 우선순위 프로세스만 계속 수행되면 낮은 우선순위 프로세스에게 _____ 현상이 일어날 수 있다.', '기아', '-', 35),

    (371, 'SELECT_DESCRIPTION', 'Priority Boost의 주요 목적을 가장 적절히 설명한 것은?', '3', '1.높은 우선순위 프로세스를 더 빨리 끝내기 위해;2.CPU 바운드 작업을 항상 최상위 큐에 두기 위해;3.기아를 방지하고 동적 프로세스 변화를 반영하기 위해;4.모든 프로세스를 무조건 같은 우선순위로 만들기 위해', 35),

    (372, 'FILL_BLANK', '총 CPU 사용 시간을 기준으로 우선순위 강등은 MLFQ의 _____ 방지를 위해 수정된 Rule 4 규칙이다.', 'cheat', '-', 35),

    (373, 'FILL_BLANK', 'Lottery 스케줄링은 각 프로세스에 여러 장의 _____을 주고, 매 타임 슬라이스마다 추첨을 통해 실행할 프로세스를 정한다.', '티켓, ticket', '-', 35),

    (374, 'FILL_BLANK', 'Stride 스케줄링에서 각 프로세스는 일정한 _____ 값을 가지고 실행될 때마다 pass 값에 이를 더한다.', '간격, stride', '-', 35),

    (375, 'SELECT_DESCRIPTION', 'Lottery 스케줄링과 Stride 스케줄링의 공통적인 한계는?', '3', '1.랜덤성으로 인한 불안정성;2.pass 값 저장의 복잡성;3.티켓 할당 방법과 수량;4.타임 슬라이스 무시', 35),

    (376, 'SELECT_DESCRIPTION', 'Stride 스케줄링에서 K=10000일 때. P1 tickets : 200, P2 tickets : 50을 가지고 있다. 이 경우 P1과 P2의 stride 값은?', '4', '1.100, 100;2.200, 50;3.5, 20;4.50, 200', 35);

-- Unit25 - 프로세스 동기화 1 (Lesson ID: 36)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (377, 'FILL_BLANK', 'CPU의 성능 향상은 주로 _____ 수의 증가와 클럭 속도 향상에 의해 이루어졌으나, 최근에는 클럭 속도 향상이 정체되어 코어 수의 증가로 발전 방향이 바뀌었다.', '트랜지스터', '-', 36),

    (378, 'SELECT_DESCRIPTION', 'Concurrency와 Parallelism의 차이를 올바르게 설명한 것은? (C - Concurrency, P - Parallelism)', '3', '1.C는 여러 코어에서 실행되고 P은 단일 코어에서 실행된다.;2.C는 동시에 실행되지만 P은 동시에 실행되지 않는다.;3.C는 시분할 실행, P은 멀티코어 실제 동시 실행.;4.C와 P은 완전히 동일한 개념이다.', 36),

    (379, 'SELECT_DESCRIPTION', '데이터 병렬성(Data Parallelism)에 대한 설명으로 옳은 것은?', '2', '1.동일한 데이터에 대해 서로 다른 작업을 수행한다.;2.동일한 작업을 여러 코어에서 수행하지만 다른 데이터를 처리한다.;3.서로 다른 작업을 동일한 데이터에 수행한다.;4.모든 코어가 동시에 동일한 명령을 수행한다.', 36),

    (380, 'SELECT_DESCRIPTION', 'Amdahl의 법칙에 따르면, 병렬 성능 향상이 제한되는 주요 요인은 무엇인가?', '3', '1.캐시 용량.;2.CPU 발열.;3.직렬 코드의 비율.;4.I/O 속도.', 36),

    (381, 'FILL_BLANK', 'Amdahl의 법칙에서 코어 수 N이 무한대로 증가할 때, 최대 성능 향상은 _____에 수렴한다.', '1/S', '-', 36),

    (382, 'FILL_BLANK', 'Amdahl의 법칙은 현실을 단순화한 모델로, 실제 시스템에서는 데이터 종속성과 _____ 문제로 인해 예측치보다 성능이 낮게 나타난다.', '동기화', '-', 36),

    (383, 'SELECT_DESCRIPTION', '8코어 CPU에서 직렬 코드 20%, 병렬 코드 80%인 프로그램의 이론적 Speedup은?', '2', '1.2.5배;2.3.33;3.5배;4.8배', 36),

    (384, 'SELECT_DESCRIPTION', 'Amdahl''s Law에 따르면, 병렬 프로그램의 성능 향상(Speedup)을 최대화하기 위한 가장 효과적인 전략은 무엇인가?', '2', '1.코어 수 증가;2.직렬 코드 비율 최소화;3.메모리 용량 증가;4.클럭 속도 향상', 36);

-- Unit25 - 프로세스 동기화 2 (Lesson ID: 37)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (385, 'FILL_BLANK', 'Race Condition은 실행 결과가 실행 순서나 스케줄링에 따라 달라지므로, 오류가 _____적이다.', '비결정론적, nondeterministic', '-', 37),

    (386, 'FILL_BLANK', '공유 자원을 동시에 접근하지 않도록 보호해야 하는 코드 영역을 _____이라고 한다.', '임계구역, critical section', '-', 37),

    (387, 'FILL_BLANK', 'Mutex를 사용하면 한 번에 오직 _____ 스레드만이 임계 구역에 들어갈 수 있다.', '하나의, 한 개의, 1개의', '-', 37),

    (388, 'SELECT_DESCRIPTION', 'lock() 함수의 의미를 올바르게 설명한 것은?', '3', '1.항상 모든 스레드가 동시에 임계 구역에 진입하도록 허용한다.;2.스레드 실행 순서를 무작위로 바꿔준다.;3.다른 스레드가 보유하지 않을 때 lock을 획득하고 임계 구역에 진입한다.;4.lock은 항상 자동으로 해제된다.', 37),

    (389, 'FILL_BLANK', 'lock을 획득한 스레드는 해당 lock의 _____라고 불리며, 다른 스레드는 임계 구역에 들어갈 수 없다.', '소유자, owner', '-', 37),

    (390, 'SELECT_DESCRIPTION', 'Well-Behaved Mutex의 조건에 해당하지 않는 것은?', '4', '1.Mutual Exclusion: 한 번에 하나의 프로세스만 lock을 가질 수 있다.;2.Progress: 다음 lock을 누가 가질지 결정이 무한히 연기되지 않는다.;3.Bounded Waiting: 모든 lock 해제 후에는 언젠가 lock을 얻을 수 있다.;4.Fairness: 락을 요청한 순서대로 반드시 획득해야 한다.', 37),

    (391, 'FILL_BLANK', 'Lock과 Unlock 연산은 반드시 _____으로 수행되어야 한다.', '원자적, atomic', '-', 37),

    (392, 'SELECT_DESCRIPTION', '다음 중 Mutex 구현에 사용되는 하드웨어 지원 기법이 아닌 것은?', '4', '1.Test-and-Set;2.Compare-and-Swap;3.Atomic Exchange;4.Context Switching', 37),

    (393, 'SELECT_DESCRIPTION', 'Spin Lock의 단점으로 옳은 것은?', '3', '1.문맥 전환 비용이 크다.;2.항상 성능이 높다.;3.공정성이 보장되지 않아 특정 스레드가 무한히 대기할 수 있다.;4.임계 구역을 보호하지 못한다.', 37),

    (394, 'SELECT_DESCRIPTION', 'Multi-CPU(SMP) 환경에서 인터럽트를 disable해도 발생할 수 있는 문제는 무엇인가?', '3', '1.단일 스레드만 실행된다.;2.인터럽트가 아예 발생하지 않는다.;3.다른 CPU에서 동시에 데이터를 읽거나 쓸 수 있다.;4.캐시 동기화가 자동으로 이루어진다.', 37),

    (395, 'SELECT_DESCRIPTION', '멀티코어 시스템에서 원자적 연산이 비싼 이유로 옳지 않은 것은?', '4', '1.캐시 flush 필수.;2.메모리 버스 lock 필수.;3.다른 CPU stall 가능성.;4.CPU 클럭 속도가 항상 낮아진다.', 37),

    (396, 'SELECT_DESCRIPTION', 'Spin Lock의 가장 큰 문제점은 무엇인가?', '2', '1.구현이 복잡하다.;2.CPU 자원을 낭비하며 공정성을 보장하지 않는다.;3.메모리 사용량이 크다.;4.원자성을 보장할 수 없다.', 37),

    (397, 'SELECT_DESCRIPTION', 'Compare-and-Swap 연산에 대한 설명으로 옳은 것은?', '2', '1.항상 메모리 값을 새 값으로 교체한다.;2.예상값과 메모리값이 같을 때만 새 값으로 교체하고 원래값을 반환한다.;3.두 메모리 위치의 값을 서로 교환한다.;4.메모리 값에 관계없이 항상 예상값을 반환한다.', 37),

    (398, 'SELECT_DESCRIPTION', 'Ticket Lock의 장점으로 옳은 것은?', '2', '1.공정성을 보장하지 않는다.;2.모든 스레드가 언젠가 lock을 획득할 수 있는 fairness를 제공한다.;3.성능이 항상 Spin Lock보다 높다.;4.스레드 수가 많을수록 무조건 효율적이다.', 37),

    (399, 'SELECT_DESCRIPTION', 'Fetch-and-Add 연산이 Ticket Lock 구현에 적합한 이유는?', '1', '1.원자적으로 값을 증가시키면서 고유한 번호를 반환하기 때문이다.;2.항상 동일한 값을 반환하기 때문이다.;3.메모리 접근 없이 동작하기 때문이다.;4.두 값을 동시에 교환할 수 있기 때문이다.', 37),

    (400, 'SELECT_DESCRIPTION', 'Condition Variable의 wait() 호출이 의미하는 것은?', '2', '1.Mutex를 잠금 상태로 유지하면서 대기한다.;2.Mutex를 해제하고 스레드를 차단한다.;3.Mutex와 Condition Variable을 동시에 삭제한다.;4.Signal 호출을 무시한다.', 37),

    (401, 'SELECT_DESCRIPTION', 'Condition Variable의 특징으로 옳지 않은 것은?', '3', '1.항상 Mutex와 함께 사용된다.;2.특정 조건을 만족할 때까지 스레드를 sleep 상태로 둘 수 있다.;3.Lock 기능만을 제공한다.;4.다른 스레드가 조건을 만족하면 signal()을 통해 깨울 수 있다.', 37),

    (402, 'SELECT_DESCRIPTION', 'Semaphores와 Mutex의 차이점으로 옳은 것은?', '2', '1.Mutex는 여러 스레드가 동시에 획득할 수 있다.;2.Semaphores는 카운트 값으로 여러 자원에 대한 동시 접근을 제어한다.;3.Mutex는 초기값을 설정할 수 없다.;4.Semaphores는 단일 스레드만 사용할 수 있다.', 37),

    (403, 'SELECT_DESCRIPTION', 'Condition Variable에서 signal() 호출의 의미를 올바르게 설명한 것은?', '2', '1.모든 대기 중인 스레드를 깨운다.;2.대기 중인 스레드 중 하나를 깨운다.;3.대기 조건을 무시하고 임계 구역에 진입한다.;4.뮤텍스를 해제하지 않는다.', 37),

    (404, 'FILL_BLANK', '세마포어 값이 음수가 되면, 그 절댓값은 대기 중인 _____의 수를 의미한다.', '스레드', '-', 37);

-- Unit25 - 프로세스 동기화 3 (Lesson ID: 38)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (405, 'FILL_BLANK', 'Deadlock이 발생하기 위한 네 가지 조건은 상호 배제, 점유와 대기, _____, 순환 대기.', '비선점', '-', 38),

    (406, 'SELECT_DESCRIPTION', 'Deadlock 발생 조건에 해당하지 않는 것은?', '4', '1.Mutual Exclusion;2.Hold and Wait;3.Circular Wait;4.Preemption of all resources', 38),

    (407, 'SELECT_DESCRIPTION', 'Deadlock을 다루는 방법 중 "시스템이 결코 데드락 상태에 들어가지 않도록 보장하는 것"은 무엇인가?', '1', '1.Deadlock Prevention;2.Deadlock Avoidance;3.Deadlock Detection;4.Deadlock Recovery', 38),

    (408, 'SELECT_DESCRIPTION', 'Deadlock Prevention 기법에 대한 설명으로 옳은 것은?', '2', '1.순환 대기를 허용한다.;2.자원 요청 순서를 강제하여 Circular Wait을 방지한다.;3.점유와 대기를 허용한다.;4.모든 자원을 공유 가능하게 만든다.', 38),

    (409, 'FILL_BLANK', 'Deadlock Avoidance에서 시스템이 안전한 상태(safe state)인지 판별하기 위해 사용하는 대표적인 알고리즘은 _____의 알고리즘이다.', 'banker, 뱅커', '-', 38),

    (410, 'SELECT_DESCRIPTION', 'Deadlock Avoidance와 Prevention의 차이를 올바르게 설명한 것은?', '2', '1.Prevention은 시스템 상태를 검사하며 Avoidance는 자원 순서를 강제한다.;2.Avoidance는 자원 할당 시 안전 상태 여부를 동적으로 검사하고 Prevention은 구조적으로 조건을 차단한다.;3.두 방법 모두 동일하다.;4.Avoidance는 프로세스 강제 종료를 포함한다.', 38),

    (411, 'SELECT_DESCRIPTION', 'Deadlock Detection에서 단일 자원 타입만 있을 경우 사용하는 그래프는 무엇인가?', '1', '1.Wait-for Graph;2.Resource Allocation Graph;3.Banker''s Graph;4.Condition Graph.', 38),

    (412, 'FILL_BLANK', 'Deadlock Detection에서 그래프 내 _____이 있으면 Deadlock이 존재한다.', '사이클, cycle', '-', 38),

    (413, 'SELECT_DESCRIPTION', 'Deadlock 복구 방법 중 "모든 프로세스를 중단하지 않고 일부만 종료하여 사이클을 깨뜨리는 방식"은 무엇인가?', '2', '1.전체 프로세스 종료;2.선택적 프로세스 종료;3.자원 무시하기;4.우선순위 상향', 38),

    (414, 'SELECT_DESCRIPTION', 'Deadlock 복구에서 자원 선점(Resource Preemption)의 단점으로 옳은 것은?', '3', '1.모든 프로세스를 즉시 종료한다.;2.항상 공정성을 보장한다.;3.동일한 프로세스가 반복적으로 희생되어 기아(Starvation)가 발생할 수 있다.;4.Banker''s Algorithm이 항상 필요하다.', 38);

-- Unit26 - 메모리 관리 1 (Lesson ID: 39)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (415, 'FILL_BLANK', '운영체제는 보통 _____ 단위로 메모리를 동적 할당한다. (예: 4KB)', '페이지, page', '-', 39),

    (416, 'SELECT_DESCRIPTION', 'malloc() 함수와 free() 함수의 차이로 옳은 것은?', '2', '1.malloc()은 메모리를 해제하고, free()는 메모리를 할당한다.;2.malloc()은 원하는 크기의 메모리를 할당하고 free()는 이를 해제한다.;3.malloc()과 free()는 동일한 기능을 수행한다.;4.free()는 포인터가 아닌 크기를 인자로 받는다.', 39),

    (417, 'SELECT_DESCRIPTION', 'C 언어에서 free()가 크기를 인자로 받지 않아도 해제가 가능한 이유는?', '1', '1.메모리 블록 헤더에 크기 정보가 저장되어 있다.;2.운영체제가 free() 호출 시 크기를 자동 계산한다.;3.항상 4KB 단위만 해제되기 때문이다.;4.free()는 내부적으로 malloc()을 다시 호출한다.', 39),

    (418, 'FILL_BLANK', '자바(Java)나 C#에서는 malloc/free 대신 _____ _____가 메모리 해제를 관리한다.', '가비지 컬렉터', '-', 39),

    (419, 'SELECT_DESCRIPTION', '동적 메모리 관리의 주요 목표와 가장 거리가 먼 것은?', '3', '1.어떤 메모리 영역이 사용 중인지 추적한다.;2.각 할당의 크기를 기록한다.;3.항상 최악의 경우 O(n) 시간에 동작해야 한다.;4.단편화를 최소화한다.', 39),

    (420, 'FILL_BLANK', '동적 메모리 관리에서 _____ 단편화는 메모리가 작은 조각으로 나뉘어 충분한 총량이 있어도 연속된 공간이 없어 할당이 불가능해지는 현상이다.', '외부', '-', 39),

    (421, 'FILL_BLANK', '동적 메모리 관리에서 _____ 단편화는 요청한 크기보다 더 큰 블록을 할당해 내부에서 공간이 낭비되는 현상이다.', '내부', '-', 39),

    (422, 'SELECT_DESCRIPTION', '외부 단편화 해결책으로 자주 언급되지만 비용이 매우 큰 방법은?', '3', '1.Binning;2.Best-Fit;3.Compaction;4.Next-Fit', 39),

    (423, 'SELECT_DESCRIPTION', 'malloc(100)을 호출했을 때 실제 할당되는 크기가 104바이트인 이유는?', '2', '1.항상 4바이트를 낭비하기 때문이다.;2.블록 헤더에 메타데이터가 포함되기 때문이다.;3.운영체제가 강제로 여유 공간을 둔다.;4.캐시 라인 정렬 때문이다.', 39),

    (424, 'SELECT_DESCRIPTION', '운영체제가 제공하는 메모리 요청 시스템 콜이 아닌 것은?', '3', '1.sbrk();2.mmap();3.free();4.brk()', 39);

-- Unit26 - 메모리 관리 2 (Lesson ID: 40)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (425, 'SELECT_DESCRIPTION', 'Free List의 기본 구조는?', '2', '1.배열로 관리한다.;2.연결 리스트로 관리하며 각 노드에 크기를 기록한다.;3.트리 구조로 관리한다.;4.해시 테이블로 관리한다.', 40),

    (426, 'SELECT_DESCRIPTION', 'Free List에서 첫 번째 충분히 큰 블록을 선택하는 전략은?', '1', '1.First-Fit;2.Best-Fit;3.Next-Fit;4.Round-Fit', 40),

    (427, 'SELECT_DESCRIPTION', 'Best-Fit 전략의 장점으로 옳은 것은?', '2', '1.항상 O(1) 시간에 탐색 가능하다.;2.외부 단편화가 상대적으로 적다.;3.항상 연속된 공간을 사용한다.;4.내부 단편화를 제거한다.', 40),

    (428, 'FILL_BLANK', 'Footers를 사용하면 free() 연산이 O_____ 시간이 될 수 있다.', '(1)', '-', 40),

    (429, 'FILL_BLANK', 'Free List의 각 블록은 크기를 기록한 _____를 가진다.', '헤더', '-', 40),

    (430, 'SELECT_DESCRIPTION', 'Free List의 장점으로 옳지 않은 것은?', '4', '1.다양한 크기의 요청을 처리할 수 있다.;2.동적 할당/해제를 지원한다.;3.연결 리스트이므로 삽입/삭제가 쉽다.;4.항상 O(1) 시간에 탐색이 가능하다.', 40),

    (431, 'SELECT_DESCRIPTION', 'Free List 방식의 가장 큰 장점은?', '2', '1.항상 O(1) 탐색이 가능하다;2.다양한 크기의 요청을 동적으로 처리할 수 있다;3.내부 단편화가 전혀 발생하지 않는다;4.Compaction이 필요 없다.', 40),

    (432, 'FILL_BLANK', 'Free List는 _____와 _____를 통해 메모리 할당 시 블록을 분리하고, 해제 시 합친다.', 'splitting, coalescing', '-', 40),

    (433, 'SELECT_DESCRIPTION', 'Next-Fit 전략의 특징으로 옳은 것은?', '3', '1.항상 가장 작은 블록을 선택한다.;2.항상 리스트의 첫 번째 블록을 선택한다.;3.마지막 검색 지점 이후부터 탐색을 이어간다.;4.항상 O(1) 시간에 동작한다.', 40),

    (434, 'SELECT_DESCRIPTION', 'Splitting과 Coalescing의 관계로 옳은 것은?', '1', '1.Splitting은 malloc 시 큰 빈 블록을 나누고, Coalescing은 free 시 인접한 빈 블록을 합친다;2.둘은 정반대 개념이다;3.Splitting만으로도 충분하다;4.Coalescing은 선택사항이다.', 40);

-- Unit26 - 메모리 관리 3 (Lesson ID: 41)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (435, 'SELECT_DESCRIPTION', '메모리 할당 시 Binning 기법의 장점으로 옳은 것은?', '2', '1.항상 가장 작은 블록을 고른다.;2.크기별로 미리 리스트를 나누어 탐색 시간을 줄인다.;3.내부 단편화를 완전히 없앤다.;4.외부 단편화를 항상 제거한다.', 41),

    (436, 'FILL_BLANK', 'malloc() 성능을 높이기 위해 크기를 2의 거듭제곱 단위로 올리는 것을 _____라고 한다.', '라운딩', '-', 41),

    (437, 'SELECT_DESCRIPTION', 'Slab allocation의 장점으로 옳은 것은?', '2', '1.항상 Compaction을 제거한다.;2.같은 크기의 객체를 미리 할당해 관리 효율을 높인다.;3.내부 단편화를 제거한다.;4.free()를 항상 자동 호출한다.', 41),

    (438, 'SELECT_DESCRIPTION', 'Per-thread arena 기법의 목적은?', '1', '1.멀티스레드 환경에서 lock 경합을 줄이고 캐시 친화도를 높인다.;2.단일 스레드 프로그램을 빠르게 만든다.;3.항상 Compaction을 제거한다.;4.free()의 속도를 낮춘다.', 41),

    (439, 'FILL_BLANK', 'Dangling pointer는 이미 _____된 메모리를 가리키는 포인터를 의미한다.', '해제', '-', 41),

    (440, 'SELECT_DESCRIPTION', 'Memory Leak의 결과로 옳은 것은?', '2', '1.항상 프로그램이 비정상 종료된다.;2.사용하지 않는 메모리가 반환되지 않아 장기 실행 시 메모리 고갈을 초래한다.;3.Free List가 손상된다.;4.항상 내부 단편화를 유발한다.', 41),

    (441, 'SELECT_DESCRIPTION', '메모리 관리 버그 중 보안 취약점으로 악용될 수 있는 것은?', '3', '1.Memory Leak;2.False Sharing;3.Double Free;4.Garbage Collection', 41),

    (442, 'SELECT_DESCRIPTION', 'Object Cache를 사용하는 이유로 옳은 것은?', '2', '1.항상 내부 단편화를 줄이기 위해.;2.자주 사용하는 객체를 미리 할당해 성능을 높이기 위해.;3.free()를 자동으로 호출하기 위해.;4.Compaction을 피하기 위해', 41),

    (443, 'SELECT_DESCRIPTION', 'Slab allocation에서 동일한 크기 객체들을 미리 할당하는 이유는?', '3', '1.메모리를 절약하기 위해;2.외부 단편화를 완전히 제거하기 위해;3.할당/해제 속도를 높이고 단편화를 줄이기 위해;4.Garbage Collection을 피하기 위해', 41),

    (444, 'SELECT_DESCRIPTION', 'Dangling Pointer와 Double Free 버그의 공통적인 특징으로 옳은 것은?', '2', '1.둘 다 항상 프로그램이 즉시 종료된다.;2.둘 다 비결정적 동작을 보여 디버깅을 어렵게 만든다.;3.둘 다 메모리 누수를 발생시킨다.;4.둘 다 컴파일 시점에 발견된다.', 41);

-- Unit27 - 가상 메모리 1 (Lesson ID: 42)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (445, 'FILL_BLANK', '가상 메모리는 프로세스마다 독립적인 _____ 공간을 제공한다.', '주소', '-', 42),

    (446, 'SELECT_DESCRIPTION', '가상 메모리의 주요 목적이 아닌 것은?', '4', '1.메모리 보호;2.프로세스 간 격리;3.실제 메모리보다 큰 주소 공간 제공;4.CPU 클럭 속도를 높인다.', 42),

    (447, 'FILL_BLANK', '하드웨어적으로 가상 주소를 물리 주소로 변환하는 장치를 _____라고 한다.', 'mmu', '-', 42),

    (448, 'SELECT_DESCRIPTION', 'Base & Bound 레지스터의 주요 역할은?', '2', '1.페이지 테이블을 관리한다.;2.프로그램이 접근할 수 있는 메모리 범위를 제한한다.;3.항상 같은 물리 주소로 매핑한다.;4.가상 주소를 랜덤하게 변환한다.', 42),

    (449, 'SELECT_DESCRIPTION', '세그멘테이션의 장점으로 옳은 것은?', '1', '1.서로 다른 영역에 서로 다른 보호 비트를 줄 수 있다.;2.외부 단편화를 줄일 수 있다.;3.항상 O(1) 접근이 가능하다.;4.페이징보다 단순하다.', 42),

    (450, 'FILL_BLANK', 'Position Independent Code는 프로그램이 어떤 _____에도 로드될 수 있도록 작성된 코드이다.', '주소', '-', 42),

    (451, 'SELECT_DESCRIPTION', 'Load-time fixup의 특징은?', '3', '1.실행 시점마다 주소를 고친다.;2.코드가 절대 위치에만 올라간다.;3.프로그램 로드 시 주소를 조정한다.;4.코드가 항상 같은 주소에 올라간다.', 42),

    (452, 'FILL_BLANK', '가상 메모리를 사용하지 않는 시스템에서는 프로세스가 _____ 주소를 직접 사용해야 한다.', '물리', '-', 42),

    (453, 'SELECT_DESCRIPTION', '세그멘테이션의 단점은 무엇인가?', '4', '1.보호 비트 제공;2.코드/데이터 분리 가능;3.유연한 메모리 관리;4.외부 단편화 발생', 42),

    (454, 'SELECT_DESCRIPTION', 'MMU가 없는 시스템에서 가상 메모리를 구현할 수 없는 이유는?', '2', '1.CPU 속도가 너무 느리기 때문이다.;2.하드웨어적으로 주소 변환을 지원하지 않기 때문이다.;3.캐시가 작기 때문이다.;4.운영체제가 지원하지 않기 때문이다.', 42);

-- Unit27 - 가상 메모리 2 (Lesson ID: 43)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (455, 'SELECT_DESCRIPTION', '페이징의 주요 목적은?', '1', '1.외부 단편화를 줄인다.;2.프로세스의 주소 공간을 고정 크기 블록으로 나눈다.;3.항상 내부 단편화를 제거한다.;4.CPU 속도를 높인다.', 43),

    (456, 'FILL_BLANK', '페이징에서 가상 주소는 페이지 번호와 페이지 내 _____으로 나뉜다.', '오프셋', '-', 43),

    (457, 'SELECT_DESCRIPTION', '페이지 크기가 작아질 때의 장점은?', '2', '1.내부 단편화가 늘어난다.;2.내부 단편화가 줄어든다.;3.외부 단편화가 줄어든다.;4.페이지 테이블 크기가 줄어든다.', 43),

    (458, 'SELECT_DESCRIPTION', '페이지 테이블의 크기를 줄이는 대표적 기법은?', '3', '1.First-Fit;2.Compaction;3.다단계 페이지 테이블;4.Base & Bound.', 43),

    (459, 'SELECT_DESCRIPTION', 'Copy-on-Write의 장점으로 옳은 것은?', '2', '1.항상 새 페이지를 즉시 복사한다.;2.실제로 쓰기(write)가 일어날 때만 페이지를 복사한다.;3.프로세스를 항상 복제하지 않는다.;4.페이지 테이블을 제거한다.', 43),

    (460, 'FILL_BLANK', '가상 주소 변환을 빠르게 하기 위해 사용되는 하드웨어 캐시는 _____이다.', 'tlb', '-', 43),

    (461, 'FILL_BLANK', 'TLB miss가 발생하면, CPU는 _____을 참조하여 주소 변환을 다시 수행한다.', '페이지 테이블, page table', '-', 43),

    (462, 'SELECT_DESCRIPTION', '페이지 테이블과 TLB의 관계로 옳은 것은?', '2', '1.페이지 테이블은 캐시이고 TLB는 메인 메모리다.;2.TLB는 페이지 테이블 매핑을 캐시한다.;3.페이지 테이블이 없으면 TLB도 없다.;4.둘은 서로 독립적이다.', 43),

    (463, 'FILL_BLANK', 'TLB에서 교체 정책으로 가장 이상적인 방식은 _____ 알고리즘이다.', '최적', '-', 43),

    (464, 'FILL_BLANK', '페이지 테이블 엔트리(PTE)의 P 비트가 0이면, 해당 페이지는 메모리에 없고 _____에 있다.', '디스크', '-', 43);

-- Unit27 - 가상 메모리 3 (Lesson ID: 44)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (465, 'FILL_BLANK', '메모리에서 디스크로 페이지를 내보내는 작업을 _____라고 한다.', '스와핑', '-', 44),

    (466, 'SELECT_DESCRIPTION', '스와핑이 필요한 이유는?', '3', '1.CPU 속도를 높이기 위해.;2.캐시 크기를 줄이기 위해.;3.물리 메모리가 한정되어 있어 부족할 때 디스크를 활용하기 위해.;4.프로그램을 항상 같은 주소에 배치하기 위해.', 44),

    (467, 'FILL_BLANK', '스와핑된 페이지를 다시 메모리에 가져와 실행을 재개하는 과정에서 _____가 발생한다.', '페이지 폴트, page fault', '-', 44),

    (468, 'SELECT_DESCRIPTION', 'Page Fault 처리 절차로 옳은 것은?', '2', '1.항상 프로세스를 종료한다.;2.디스크에서 해당 페이지를 읽어와 페이지 테이블을 갱신한다.;3.CPU 캐시를 초기화한다.;4.새로운 프로세스를 생성한다.', 44),

    (469, 'SELECT_DESCRIPTION', 'LRU 페이지 교체 정책의 기본 아이디어는?', '1', '1.가장 오래 사용하지 않은 페이지를 교체한다.;2.가장 최근 사용한 페이지를 교체한다.;3.랜덤하게 페이지를 교체한다.;4.항상 첫 번째 페이지를 교체한다.', 44),

    (470, 'SELECT_DESCRIPTION', 'FIFO 페이지 교체 정책의 기본 아이디어로 옳은 것은?', '1', '1.가장 먼저 메모리에 들어온 페이지를 교체한다.;2.가장 오랫동안 사용하지 않은 페이지를 교체한다.;3.가장 최근에 사용한 페이지를 교체한다.;4.임의의 페이지를 교체한다.', 44),

    (471, 'SELECT_DESCRIPTION', '페이지 교체에서 Random 정책의 특징은?', '2', '1.항상 최적의 교체를 보장한다.;2.단순히 임의의 페이지를 교체한다.;3.가장 오랫동안 사용하지 않은 페이지를 교체한다.;4.Dirty 페이지를 우선 교체한다.', 44),

    (472, 'FILL_BLANK', 'Dirty 페이지를 교체할 때는 반드시 _____에 기록해야 한다.', '디스크', '-', 44),

    (473, 'SELECT_DESCRIPTION', 'Dirty 페이지보다 Clean 페이지를 먼저 교체하는 이유는?', '2', '1.Dirty 페이지는 항상 더 자주 쓰인다.;2.Clean 페이지는 디스크에 다시 기록할 필요가 없어 비용이 적기 때문이다.;3.Clean 페이지는 항상 작기 때문이다.;4.Dirty 페이지는 이미 디스크에 있다.', 44),

    (474, 'FILL_BLANK', 'RAM은 대용량 디스크를 위한 고속 _____로 볼 수 있다.', '캐시', '-', 44),

    (475, 'SELECT_DESCRIPTION', '페이지 교체 정책 중 가장 구현이 간단한 것은?', '1', '1.FIFO;2.LRU;3.Optimal;4.Clock', 44),

    (476, 'FILL_BLANK', '페이지 교체 정책의 목표는 _____을 최대화하는 것이다.', '히트율, 적중률', '-', 44);

-- Unit28 - 파일 시스템 & 저장장치 1 (Lesson ID: 45)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (477, 'FILL_BLANK', '하드 디스크의 데이터 최소 단위는 _____이며, 보통 512바이트 또는 4096바이트이다.', '섹터', '-', 45),

    (478, 'SELECT_DESCRIPTION', '실린더(cylinder)를 올바르게 설명한 것은?', '3', '1.디스크의 회전 속도를 의미한다.;2.단일 플래터의 하나의 트랙을 의미한다.;3.여러 플래터의 같은 트랙 위치를 모은 집합이다.;4.섹터를 묶어놓은 집합이다.', 45),

    (479, 'FILL_BLANK', '디스크의 회전 속도는 _____ 단위로 측정된다.', 'rpm', '-', 45),

    (480, 'SELECT_DESCRIPTION', '디스크 지연 요소에 포함되지 않는 것은?', '4', '1.Seek Delay;2.Rotational Delay;3.Transfer Time;4.CPU Scheduling Time', 45),

    (481, 'SELECT_DESCRIPTION', 'Rotational Delay는 무엇을 의미하는가?', '2', '1.디스크를 회전시키는 데 걸리는 시간;2.원하는 섹터가 헤드 아래로 올 때까지 기다리는 시간;3.데이터를 디스크에 기록하는 시간;4.CPU 캐시를 접근하는 시간.', 45),

    (482, 'FILL_BLANK', 'I/O 총 시간은 Seek Time, Rotational Delay, _____의 합으로 계산된다.', 'transfer time', '-', 45),

    (483, 'SELECT_DESCRIPTION', '디스크에서 순차 접근(sequential access)의 장점은?', '1', '1.회전 및 탐색 지연을 최소화할 수 있다.;2.항상 디스크의 바깥쪽에서만 읽는다.;3.캐시를 사용할 필요가 없다.;4.디스크 속도에 영향을 받지 않는다.', 45),

    (484, 'FILL_BLANK', '디스크의 바깥쪽 트랙은 안쪽 트랙보다 더 ___은 데이터를 담을 수 있다.', '많', '-', 45),

    (485, 'SELECT_DESCRIPTION', 'Torn Write 문제가 발생하는 경우는?', '3', '1.Read Caching이 실패했을 때;2.Disk RPM이 너무 낮을 때;3.여러 섹터를 연속으로 쓰다가 중간에 실패할 때;4.디스크가 포맷되지 않았을 때.', 45),

    (486, 'SELECT_DESCRIPTION', '디스크의 랜덤 I/O 성능이 낮은 이유는?', '3', '1.디스크 캐시 크기가 작기 때문이다.;2.CPU 속도가 느리기 때문이다.;3.Seek Delay와 Rotational Delay가 매번 발생하기 때문이다.;4.섹터 크기가 작기 때문이다.', 45),

    (487, 'SELECT_DESCRIPTION', 'Write-back Cache의 위험성으로 옳은 것은?', '2', '1.데이터를 더 빠르게 읽을 수 있다.;2.캐시에만 기록되고 실제 디스크에는 아직 쓰이지 않아 전원 장애 시 손실될 수 있다.;3.디스크 RPM이 증가한다.;4.순차 접근이 더 빨라진다.', 45);

-- Unit28 - 파일 시스템 & 저장장치 2 (Lesson ID: 46)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (488, 'SELECT_DESCRIPTION', 'FCFS 디스크 스케줄링의 특징은?', '1', '1.요청 순서대로 처리해 공정성은 높으나 성능이 낮다.;2.탐색 시간을 최소화한다.;3.헤드 이동을 최소화한다.;4.특정 요청을 무한히 지연시킬 수 있다.', 46),

    (489, 'FILL_BLANK', 'SSTF는 _____ Seek Time First의 약자이다.', 'shortest', '-', 46),

    (490, 'SELECT_DESCRIPTION', 'SSTF 스케줄링의 단점은?', '3', '1.탐색 시간을 줄일 수 없다.;2.항상 최적해를 보장하지 않는다.;3.특정 요청이 기아(starvation)에 빠질 수 있다.;4.항상 FCFS보다 느리다.', 46),

    (491, 'SELECT_DESCRIPTION', '디스크 스케줄링이 필요한 가장 큰 이유는?', '1', '1.헤드 이동 거리를 줄여 성능을 높이기 위해.;2.디스크 RPM을 낮추기 위해.;3.섹터 크기를 늘리기 위해.;4.캐시를 제거하기 위해.', 46),

    (492, 'FILL_BLANK', 'SATA에서 지원하는 명령 큐 기능은 _____라고 불린다.', 'native command queuing, ncq', '-', 46),

    (493, 'SELECT_DESCRIPTION', 'RAID의 기본 목적이 아닌 것은?', '4', '1.성능 향상;2.용량 확대;3.신뢰성 향상;4.CPU 속도 향상', 46),

    (494, 'FILL_BLANK', 'RAID 0은 데이터를 여러 디스크에 _____하여 성능을 높인다.', '스트라이핑, striping', '-', 46),

    (495, 'SELECT_DESCRIPTION', 'RAID 0의 단점으로 옳은 것은?', '2', '1.용량을 절반만 사용한다.;2.디스크 하나만 고장 나도 전체 데이터가 손실된다.;3.쓰기 성능이 낮다.;4.항상 RAID 1보다 안전하다.', 46),

    (496, 'FILL_BLANK', 'RAID 1은 데이터를 _____하여 신뢰성을 높인다.', '미러링, mirroring', '-', 46),

    (497, 'SELECT_DESCRIPTION', 'RAID 5가 RAID 4보다 나은 이유는?', '3', '1.항상 읽기 성능이 높다.;2.패리티 디스크가 두 개다.;3.패리티 블록을 모든 디스크에 분산시켜 병목을 줄인다.;4.RAID 4보다 더 적은 디스크가 필요하다.', 46);

-- Unit28 - 파일 시스템 & 저장장치 3 (Lesson ID: 47)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (498, 'SELECT_DESCRIPTION', 'SSD에서 쓰기 증폭(write amplification)이 발생하는 원인은?', '2', '1.캐시 크기가 작아서;2.페이지 단위 쓰기와 블록 단위 삭제 차이 때문에;3.RPM이 너무 낮아서;4.CPU 클럭이 낮아서', 47),

    (499, 'FILL_BLANK', 'SSD에서 쓰여진 페이지를 지우려면 전체 _____을 삭제해야 한다.', '블록, block', '-', 47),

    (500, 'SELECT_DESCRIPTION', 'SSD에서 Garbage Collection의 역할은?', '3', '1.항상 데이터를 삭제한다.;2.전력 소모를 줄인다.;3.유효한 페이지를 모아 비어 있는 블록을 확보한다.;4.Wear Leveling을 제거한다.', 47),

    (501, 'FILL_BLANK', 'SSD는 일정 횟수 이상 쓰면 셀 수명이 다하기 때문에 _____ 기법으로 쓰기를 분산시킨다.', 'wear leveling', '-', 47),

    (502, 'SELECT_DESCRIPTION', 'TRIM 명령어의 목적은?', '2', '1.SSD 속도를 낮춘다.;2.Garbage Collection 효율을 높인다.;3.데이터를 무조건 지운다.;4.항상 읽기 속도를 줄인다.', 47),

    (503, 'FILL_BLANK', 'SSD의 _____는 논리 블록 주소를 실제 플래시 페이지로 매핑하고, GC와 Wear Leveling을 관리한다.', '컨트롤러, controller', '-', 47),

    (504, 'SELECT_DESCRIPTION', 'SSD가 HDD보다 불리한 점은?', '3', '1.랜덤 접근 속도가 낮다.;2.전력 소모가 크다.;3.쓰기 횟수 제한으로 수명이 짧다.;4.기계적 충격에 취약하다.', 47),

    (505, 'FILL_BLANK', 'SSD의 기본 데이터 쓰기 단위는 _____이며, 보통 4KB~16KB이다.', '페이지, page', '-', 47),

    (506, 'SELECT_DESCRIPTION', 'SSD에서 블록 단위 삭제로 인해 발생하는 성능 문제는?', '2', '1.캐시 미스;2.Write Amplification;3.Random I/O Bottleneck;4.Compaction', 47),

    (507, 'FILL_BLANK', 'SSD의 수명을 늘리기 위해 표기 용량보다 실제로는 더 큰 용량의 메모리를 탑재하는 기법을 _____라고 한다.', '오버 프로비저닝, over-provisioning', '-', 47),

    (508, 'SELECT_DESCRIPTION', 'SSD에서 Wear Leveling의 목적은?', '3', '1.SSD 속도를 늦춘다.;2.특정 셀에 집중적으로 쓰기를 유도한다.;3.모든 셀에 고르게 쓰기를 분산해 수명을 늘린다.;4.전력 소모를 늘린다.', 47);

-- Unit01 - 데이터베이스 시스템 1 (Lesson ID: 48)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (509, 'FILL_BLANK', '데이터는 처리되지 않은 _____의 집합이다.', '사실', '-', 48),

    (510, 'FILL_BLANK', '3단계 스키마에서 사용자별 뷰를 정의하는 것은 _____ 스키마이다.', '1', '1.외부(External);2.개념(Conceptual);3.내부(Internal);4.전역(Global)', 48),

    (511, 'FILL_BLANK', '3단계 스키마에서 저장 구조와 접근 경로를 기술하는 것은 _____ 스키마이다.', '3', '1.외부(External);2.개념(Conceptual);3.내부(Internal/Physical);4.논리(Logical)', 48),

    (512, 'FILL_BLANK', '3단계 스키마의 핵심 목적은 응용과 데이터 저장 간 _____을/를 낮추는 것이다.', '1', '1.결합도;2.중복도;3.비용;4.지연시간', 48),

    (513, 'FILL_BLANK', '데이터 사전/카탈로그는 _____에 대한 _____을/를 저장한다.', '1', '1.데이터 - 메타데이터;2.트랜잭션 - 로그;3.인덱스 - 레코드;4.결과 - 캐시', 48),

    (514, 'FILL_BLANK', 'DBMS 사용자 역할에 속하지 않는 것은 _____이다.', '4', '1.DBA;2.응용 프로그래머;3.최종 사용자;4.프린터 관리자', 48),

    (515, 'FILL_BLANK', '데이터 독립성은 스키마 변경 시 _____의 영향이 최소화됨을 뜻한다.', '2', '1.운영체제;2.응용프로그램;3.네트워크 스위치;4.프린터 드라이버', 48),

    (516, 'FILL_BLANK', '논리적 독립성은 _____ 스키마 변경이 외부 스키마와 응용에 영향을 거의 주지 않음을 의미한다.', '3', '1.파일;2.내부;3.개념;4.운영체제', 48),

    (517, 'FILL_BLANK', '물리적 독립성은 저장 구조나 _____변경이 개념 스키마에 영향을 거의 주지 않음을 의미한다.', '1', '1.접근 경로;2.엔터티 관계;3.사용자 뷰;4.도메인 제약', 48),

    (518, 'FILL_BLANK', '스키마를 정의하는 언어는 _____이고, 데이터를 조작하는 언어는 _____이다.', '4', '1.TCL·DCL;2.DML·DDL;3.DCL·DDL;4.DDL·DML', 48),

    (519, 'FILL_BLANK', 'DBMS의 쿼리 처리기에는 파서와 _____가/이 포함되어 있다.', '옵티마이저, optimizer', '-', 48),

    (520, 'FILL_BLANK', '트랜잭션의 ACID에서 C(일관성)는 트랜잭션 전후로 _____이/가 유지됨을 의미한다.', '2', '1.동시 실행 수;2.무결성 제약;3.로그 크기;4.캐시 적중률', 48);

-- Unit01 - 데이터베이스 시스템 2 (Lesson ID: 49)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (521, 'FILL_BLANK', '3단계 스키마는 외부(External), _____, 내부(Internal) 스키마로 구성된다.', '1', '1.개념(Conceptual);2.물리(Physical);3.전역(Global);4.논리(Logical)', 49),

    (522, 'SELECT_DESCRIPTION', '물리적 데이터 독립성을 가장 잘 설명하는 것은?', '2', '1.외부 스키마 변경이 내부에 전파됨;2.내부 저장 구조 변경이 외부 스키마에 영향을 주지 않음;3.개념 스키마 변경이 내부 스키마를 고정함;4.사용자 뷰가 테이블을 자동 생성함', 49),

    (523, 'SELECT_DESCRIPTION', '논리적 데이터 독립성 사례로 적절한 것은?', '3', '1.인덱스 유형 변경;2.파일 블록 크기 조정;3.개념 스키마에 속성 추가 후 기존 사용자 뷰 유지;4.버퍼 캐시 크기 조절', 49),

    (524, 'FILL_BLANK', '외부-개념 매핑은 _____와 개념 스키마 간의 대응을 정의한다.', '4', '1.운영체제;2.내부 스키마;3.저장 파일;4.사용자 뷰', 49),

    (525, 'FILL_BLANK', '내부 스키마는 데이터의 _____ 표현과 접근 경로, 저장 구조를 기술한다.', '물리적', '-', 49),

    (526, 'SELECT_DESCRIPTION', '다음 변경 중 애플리케이션 수정 없이 가능해야 하는 이상적인 경우는? (논리/물리 독립성 관점)', '4', '1.B+트리 → 해시 인덱스 교체;2.외부 뷰의 열 순서 변경;3.데이터파일 페이지 크기 변경;4.모두 가능해야 함', 49),

    (527, 'FILL_BLANK', '개념-내부 매핑은 개념 스키마의 구조를 _____에 대응시키는 규칙이다.', '1', '1.내부 저장 구조;2.사용자 뷰;3.외부 스키마;4.운영체제 커널', 49),

    (528, 'SELECT_DESCRIPTION', '"테이블을 수직 분할하여 저장했지만 사용자 뷰는 기존 컬럼 집합을 그대로 보여준다." 이 설명에 해당하는 성질은?', '2', '1.논리적 독립성;2.물리적 독립성;3.참조 무결성;4.정규화', 49),

    (529, 'FILL_BLANK', '외부 스키마는 _____ 관점에서 데이터 표현을 제공하여 개별 사용자 요구를 반영한다.', '1', '1.사용자/응용;2.하드웨어;3.운영체제;4.네트워크', 49),

    (530, 'SELECT_DESCRIPTION', '"개념 스키마 변경이 외부 스키마에 미치는 영향 최소화"를 무엇이라 하는가?', '3', '1.참조 무결성;2.물리적 독립성;3.논리적 독립성;4.정규화', 49),

    (531, 'SELECT_DESCRIPTION', '다음 중 3단계 스키마 구조의 주요 목적으로 보기 어려운 것은?', '3', '1.데이터 독립성;2.보안/뷰 제공;3.성능 고정(튜닝 불가);4.다양한 응용 지원', 49),

    (532, 'SELECT_DESCRIPTION', '다음 설명 중 옳은 것만을 모두 고른 것은? 1.외부 스키마: 사용자/응용별 뷰를 제공한다. 2.개념 스키마: 조직 전체의 통합 논리 구조를 정의한다. 3.내부 스키마: 물리 저장 구조와 접근 경로를 기술한다. 4.외부-개념 매핑: 사용자 뷰와 개념 스키마 간의 대응을 정의한다.', '4', '1.1, 2;2.1, 3, 4;3.1, 2, 4;4.1, 2, 3, 4', 49);

-- Unit01 - 데이터베이스 시스템 3 (Lesson ID: 50)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (533, 'SELECT_DESCRIPTION', '다음 중 DBA의 주요 역할로 가장 거리가 먼 것은?', '3', '1.권한 관리;2.백업/복구;3.쿼리 옵티마이저 개발;4.성능 모니터링', 50),

    (534, 'SELECT_DESCRIPTION', 'CREATE TABLE, ALTER TABLE, DROP VIEW는 각각 어떤 범주의 언어인가?', '1', '1.모두 DDL;2.모두 DML;3.모두 DCL;4.모두 TCL', 50),

    (535, 'SELECT_DESCRIPTION', 'GRANT SELECT ON T TO U; 문은 어떤 언어 범주에 해당하는가?', '3', '1.DDL;2.DML;3.DCL;4.TCL', 50),

    (536, 'SELECT_DESCRIPTION', '트랜잭션의 종료를 명시하는 명령은?', '1', '1.COMMIT/ROLLBACK;2.GRANT/REVOKE;3.CREATE/DROP;4.ANALYZE/EXPLAIN', 50),

    (537, 'FILL_BLANK', 'DML은 _____ 형태와 _____ 형태가 모두 존재할 수 있다.', '1', '1.절차적·비절차적;2.정규화·비정규화;3.동기·비동기;4.고정·가변', 50),

    (538, 'FILL_BLANK', '일반 사용자(naive user)는 보통 _____를 통해 사전에 작성된 질의나 화면으로 DB에 접근한다.', '2', '1.DDL 스크립트;2.응용 프로그램;3.백업 스케줄러;4.클러스터 매니저', 50),

    (539, 'SELECT_DESCRIPTION', '다음 SQL을 분류하라 - INSERT, UPDATE, DELETE, SELECT … FOR UPDATE, SAVEPOINT S1.', '4', '1.TCL;2.DDL;3.DCL;4.DML', 50),

    (540, 'SELECT_DESCRIPTION', '응용 개발자의 주 업무로 보기 적절한 것은?', '3', '1.스키마 표준 수립;2.정기 백업/복구;3.트리거/프로시저 작성 및 CRUD 구현;4.저장장치 교체', 50),

    (541, 'FILL_BLANK', 'REVOKE는 _____에 속하며, _____을 의미한다.', '1', '1.DCL·권한 회수;2.DDL·스키마 삭제;3.TCL·트랜잭션 종료;4.DML·데이터 삭제', 50),

    (542, 'FILL_BLANK', '테이블 스키마를 정의·변경·삭제하는 명령의 집합을 _____라고 한다.', '3', '1.DCL;2.DML;3.DDL;4.TCL', 50),

    (543, 'SELECT_DESCRIPTION', '다음 SQL과 분류의 짝이 올바른 것은?', '2', '1.GRANT SELECT ON T TO U; - DML;2.CREATE TABLE T(...); - DDL;3.REVOKE UPDATE ON T FROM U; - DML;4.INSERT INTO T VALUES(...); - DDL', 50),

    (544, 'FILL_BLANK', '_____은 스키마 정의·변경·삭제에 해당하고, _____은 데이터 조회·조작에 해당하며, _____은 권한 부여·회수에 해당한다.', '3', '1.DDL, DCL, DML;2.DML, DDL, DCL;3.DDL, DML, DCL;4.DCL, DDL, DML', 50);

-- Unit02 - 관계형 모델 1 (Lesson ID: 51)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (545, 'SELECT_DESCRIPTION', '다음 중 릴레이션의 기본 구성 요소가 아닌 것은?', '4', '1.속성(Attribute);2.튜플(Tuple);3.카디널리티(Cardinality);4.인덱스(Index)', 51),

    (546, 'FILL_BLANK', '릴레이션의 _____는 속성의 개수, _____는 튜플의 개수를 의미한다.', '1', '1.차수-카디널리티;2.카디널리티-차수;3.도메인-슈퍼키;4.슈퍼키-도메인', 51),

    (547, 'SELECT_DESCRIPTION', '최소성과 유일성을 모두 만족하는 키를 무엇이라 하는가?', '2', '1.슈퍼키;2.후보키;3.기본키;4.대체키', 51),

    (548, 'SELECT_DESCRIPTION', '다음 설명 중 옳은 것만을 모두 고르시오. ① 모든 기본키는 후보키이다. ② 모든 후보키는 슈퍼키이다. ③ 슈퍼키는 항상 최소성을 만족한다. ④ 외래키는 반드시 NULL을 가질 수 없다.', '1', '1.①, ②;2.①, ③;3.②, ④;4.①, ②, ③, ④', 51),

    (549, 'SELECT_DESCRIPTION', '기본키 선정 기준으로 옳지 않은 것은?', '3', '1.변경 가능성이 낮은 속성을 고른다;2.가능한 짧은 길이가 좋다;3.의미 있는 자연키를 반드시 사용한다;4.NULL/중복이 불가능해야 한다', 51),

    (550, 'SELECT_DESCRIPTION', 'Member(employee_no UNIQUE, email UNIQUE, phone UNIQUE, name)에서 후보키 집합과 추천 기본키의 조합으로 옳은 것은?', '1', '1.후보키={employee_no},{email},{phone} / 기본키=employee_no;2.후보키={employee_no},{email} / 기본키=email;3.후보키={email},{phone} / 기본키=phone;4.후보키={employee_no},{name} / 기본키=name', 51),

    (551, 'SELECT_DESCRIPTION', '다음 DDL에서 기본키는 무엇인가? CREATE TABLE Enrollment( student_id BIGINT NOT NULL, course_id BIGINT NOT NULL, enrolled_at TIMESTAMP NOT NULL, PRIMARY KEY (student_id, course_id), FOREIGN KEY (student_id) REFERENCES Student(id), FOREIGN KEY (course_id) REFERENCES Course(id) );', '3', '1.student_id;2.course_id;3.(student_id, course_id);4.enrolled_at', 51),

    (552, 'SELECT_DESCRIPTION', '외래키에 대한 설명으로 옳은 것은?', '2', '1.외래키는 항상 기본키여야 한다;2.외래키는 참조 대상의 후보키/기본키를 참조한다;3.외래키는 NULL이 될 수 없다;4.외래키는 항상 UNIQUE여야 한다', 51),

    (553, 'SELECT_DESCRIPTION', '한 주문에 여러 주문상세. 같은 주문에서 같은 상품은 한 번만 담을 수 있음. 인조키 금지, 다른 테이블이 OrderItem 직접 참조하지 않음, PK는 업무 속성만 사용. 가장 타당한 PK 설계는?', '2', '1.id + (order_id, product_id) UNIQUE;2.(order_id, product_id) 복합 PK;3.product_id 단일 PK;4.order_id 단일 PK', 51),

    (554, 'SELECT_DESCRIPTION', '다음 중 참조 무결성을 가장 강하게 보장하는 삭제 정책은?', '3', '1.ON DELETE RESTRICT;2.ON DELETE SET NULL;3.ON DELETE CASCADE;4.ON DELETE NO ACTION', 51),

    (555, 'FILL_BLANK', '기본키로 선택되지 않은 후보키를 _____라 하고, 업무 의미와 무관한 인조 식별자를 _____라 한다.', '1', '1.대체키·서로게이트 키;2.슈퍼키·후보키;3.기본키·외래키;4.복합키·부분키', 51),

    (556, 'FILL_BLANK', 'Category(id PK, name, parent_id FK→Category.id)에서 루트 카테고리를 허용하려면 가장 적절한 제약은?', '2', '1.parent_id NOT NULL;2.parent_id NULL 허용;3.parent_id UNIQUE;4.parent_id에 기본키 부여', 51);

-- Unit02 - 관계형 모델 2 (Lesson ID: 52)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (557, 'SELECT_DESCRIPTION', '엔터티 무결성(Entity Integrity) 규칙으로 옳은 것은?', '3', '1.기본키는 NULL 가능;2.기본키는 중복 가능;3.기본키는 NULL 불가·유일해야 한다;4.외래키는 반드시 기본키여야 한다', 52),

    (558, 'FILL_BLANK', '세 가지 무결성은 엔티티 무결성, 참조 무결성, _____ 무결성이다.', '도메인', '-', 52),

    (559, 'SELECT_DESCRIPTION', '다음 중 엔터티 무결성을 위반하는 DDL은?', '3', '1.CREATE TABLE A(id INT PRIMARY KEY, name TEXT NOT NULL);2.CREATE TABLE B(id INT, name TEXT, PRIMARY KEY (id));3.CREATE TABLE C(id INT NULL, PRIMARY KEY (id));4.CREATE TABLE D(a INT, b INT, PRIMARY KEY (a, b))', 52),

    (560, 'SELECT_DESCRIPTION', '잘못된 선지를 골라주세요.', '1', '1.WHERE col = NULL은 참인 행을 찾는다.;2.COUNT(col)은 NULL을 제외한다.;3.WHERE col <> 5는 col이 NULL인 행은 잡아내지 않는다.;4.COUNT(DISTINCT col)은 NULL을 제외한다.', 52),

    (561, 'SELECT_DESCRIPTION', 'Product(category_id FK → Category.id)에서 카테고리 삭제 시 상품은 남기되, 소속만 제거하려면?', '3', '1.ON DELETE RESTRICT + category_id NOT NULL;2.ON DELETE CASCADE + category_id NOT NULL;3.ON DELETE SET NULL + category_id NULL 허용;4.ON DELETE NO ACTION + category_id NOT NULL', 52),

    (562, 'SELECT_DESCRIPTION', '다음 쿼리가 결과를 전혀 반환하지 않는다. 이유와 올바른 대안은? (Blacklist.user_id에 NULL이 하나라도 있으면 어떤 문제가?) SELECT * FROM Order o WHERE o.user_id NOT IN (SELECT user_id FROM Blacklist);', '2', '1.NOT IN은 NULL과 상관없다;2.NOT EXISTS로 바꾸거나 서브 쿼리에서 WHERE user_id IS NOT NULL을 추가;3.IN으로 바꾸면 된다;4.IS NOT NULL만 쓰면 된다', 52),

    (563, 'SELECT_DESCRIPTION', '일반적인 RDBMS에서 UNIQUE(email) 제약의 동작으로 옳은 것은?', '2', '1.email = NULL은 한 행만 허용;2.email = NULL은 여러 행도 허용될 수 있다;3.UNIQUE는 항상 NULL을 금지;4.DB에 따라 UNIQUE가 중복도 허용', 52),

    (564, 'SELECT_DESCRIPTION', 'price가 0보다 커야 하고 비어 있으면 안 된다. 가장 적절한 제약 조합은?', '3', '1.CHECK (price > 0);2.price NOT NULL;3.price NOT NULL CHECK (price > 0);4.DEFAULT 0만 지정', 52),

    (565, 'SELECT_DESCRIPTION', 'Subscription(start_date DATE NOT NULL, end_date DATE NULL)에서 "진행중 구독은 end_date가 NULL이고, 종료된 구독은 end_date ≥ start_date여야 한다." 올바른 CHECK는?', '2', '1.CHECK (end_date >= start_date);2.CHECK (end_date IS NULL OR end_date >= start_date);3.CHECK (end_date IS NOT NULL AND end_date >= start_date);4.CHECK (start_date <= end_date OR end_date = '')', 52),

    (566, 'SELECT_DESCRIPTION', '다음 테이블에서 어떤 INSERT가 실패할까? CREATE TABLE T( a INT, b INT, PRIMARY KEY (a,b) );', '4', '1.INSERT INTO T(a,b) VALUES (1,1);2.INSERT INTO T(a,b) VALUES (1,NULL);3.INSERT INTO T(a,b) VALUES (NULL,1);4.2)와 3) 모두', 52),

    (567, 'SELECT_DESCRIPTION', '다음 정의에서 어떤 문제가 있는가? CREATE TABLE UserProfile( user_id BIGINT NOT NULL, profile_img_url TEXT, FOREIGN KEY (user_id) REFERENCES User(id) ON DELETE SET NULL );', '2', '1.FK가 PK를 참조하지 않는다;2.ON DELETE SET NULL이지만 user_id가 NOT NULL;3.profile_img_url은 NULL이면 안 된다;4.FOREIGN KEY에는 UNIQUE가 필요', 52),

    (568, 'SELECT_DESCRIPTION', '기본값과 NULL에 관한 설명으로 옳은 것은? CREATE TABLE Log( level INT NOT NULL DEFAULT 1 );', '2', '1.INSERT INTO Log(level) VALUES (NULL);는 DEFAULT가 적용된다;2.INSERT INTO Log DEFAULT VALUES;는 level=1로 들어간다;3.INSERT INTO Log(level) VALUES (2);는 에러;4.DEFAULT는 SELECT시에만 적용', 52);

-- Unit03 - 관계대수 1 (Lesson ID: 53)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (569, 'SELECT_DESCRIPTION', 'A={1,2,3}, B={3,4,5}일 때 A∪B는?', '3', '1.{1, 2, 3};2.{3};3.{1,2,3,4,5};4.{4, 5}', 53),

    (570, 'SELECT_DESCRIPTION', 'A={a,b,c}, B={b,c,d}일 때 A와 B의 교집합은?', '2', '1.{a,d};2.{b,c};3.{a,b,c,d};4.{}', 53),

    (571, 'SELECT_DESCRIPTION', 'A={1,2,3,4}, B={3,4,5}일 때 A-B는?', '1', '1.{1,2};2.{3,4};3.{5};4.{1,2,5}', 53),

    (572, 'SELECT_DESCRIPTION', 'A={1,2}, B={x,y}일 때 A x B(데카르트 곱)는?', '1', '1.{(1,x),(1,y),(2,x),(2,y)};2.{(x,1),(y,1),(x,2),(y,2)};3.{1,2,x,y};4.{(1,2),(x,y)}', 53),

    (573, 'FILL_BLANK', '항상 교환법칙이 성립하는 두 연산은 합집합과 _____입니다.', '교집합', '-', 53),

    (574, 'FILL_BLANK', '항상 결합 법칙이 성립하는 두 연산은 합집합과 _____입니다.', '교집합', '-', 53),

    (575, 'SELECT_DESCRIPTION', '다음 중 항상 참인 등식은?', '2', '1.A x (B 합집합 C) = (A x B) 교집합 (A x C);2.A x (B 교집합 C) = (A x B) 교집합 (A x C);3.A - (B 합집합 C) = (A-B) 합집합 (A-C);4.A - (B 교집합 C) = (A-B) 교집합 (A-C)', 53),

    (576, 'SELECT_DESCRIPTION', '보편집합 U와 공집합(빈집합) {}에 대해 항상 참인 것을 고르시오.', '1', '1.A 합집합 {} = A, A 교집합 U = A;2.A 합집합 U = {}, A 교집합 {} = A;3.A 합집합 {} = {}, A 교집합 U = U;4.A 합집합 U = A, A 교집합 {} = U', 53),

    (577, 'SELECT_DESCRIPTION', '|A|=20, |B|=15, |A 교집합 B|=5일 때 |A 합집합 B|는?', '2', '1.25;2.30;3.35;4.40', 53),

    (578, 'SELECT_DESCRIPTION', '전체 원소가 100개이고 |A|=60, |B|=50, |A 교집합 B|=20일 때 A도 B도 아닌 원소의 수는?', '3', '1.0;2.5;3.10;4.20', 53),

    (579, 'SELECT_DESCRIPTION', 'A={1,2,3}, B={3,4,5}일 때 (A-B) 합집합 (B-A)는?', '2', '1.{3};2.{1,2,4,5};3.{1,2,3,4,5};4.{}', 53),

    (580, 'SELECT_DESCRIPTION', '|A|=4, |B|=10, |C|=3이고 C는 B의 부분 집합일 때 |A x (B-C)|는?', '4', '1.7;2.12;3.21;4.28', 53);

-- Unit03 - 관계대수 2 (Lesson ID: 54)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (581, 'SELECT_DESCRIPTION', 'Student(sid, name, dept) 스키마가 있을 때, "CS 학과 학생들의 이름만"에 해당하는 식은?', '1', '1.π name ( σ dept=''CS'' ( Student ) );2.σ dept=''CS'' ( π name ( Student ) );3.π dept ( σ name=''CS'' ( Student ) );4.π name ( Student ▷◁ Course )', 54),

    (582, 'SELECT_DESCRIPTION', 'Enroll(sid, cid) 스키마가 있을 때, "DB101을 수강한 학생 sid 목록"에 해당하는 식은?', '1', '1.π sid ( σ cid=''DB101'' ( Enroll ) );2.σ cid=''DB101'' ( π sid ( Enroll ) );3.π name ( σ cid=''DB101'' ( Enroll ) );4.π cid ( σ sid=''DB101'' ( Enroll ) )', 54),

    (583, 'FILL_BLANK', 'Student(sid, name), Enroll(sid, cid), Course(cid, title) 스키마가 있을 때, "수강한 학생 이름과 과목 제목(title)"을 얻는 식의 빈칸을 채우시오. π name, title ( ( Student _____ Enroll ) _____ Course )', '1', '1.▷◁ , ▷◁;2.▷◁ , ÷;3.÷ , ▷◁;4.▷◁ , σ', 54),

    (584, 'FILL_BLANK', 'Student(sid, name), Enroll(sid, cid, grade) 스키마가 있을 때, "A학점을 받은 학생 이름"을 σ, π, ▷◁로만 표현하시오. → π name ( Student _____ σ grade=''A'' ( Enroll ) )', '1', '1.▷◁;2.π;3.σ;4.÷', 54),

    (585, 'SELECT_DESCRIPTION', 'Teaches(pid, cid, term), Course(cid, title) 스키마가 있을 때, "pid=10 교수가 2025S 학기에 가르친 과목 제목(title)"은?', '1', '1.π title ( σ pid=10 ∧ term=''2025S'' ( Teaches ) ▷◁ Course );2.π title ( Teaches ▷◁ σ pid=10 ( Course ) );3.σ pid=10 ( π title ( Teaches ▷◁ Course ) );4.π cid ( σ pid=10 ∧ term=''2025S'' ( Teaches ) )', 54),

    (586, 'FILL_BLANK', 'Enroll(sid, cid), Course(cid, dept) 스키마가 있을 때, "CS 학과에서 개설된 모든 과목을 수강한 학생 sid"를 ÷로 표현하시오. Enroll _____ π cid ( σ dept=''CS'' ( Course ) )', '4', '1.▷◁;2.π;3.σ;4.÷', 54),

    (587, 'SELECT_DESCRIPTION', 'Enroll(sid, cid), Req(cid) 스키마가 있을 때, "Req의 모든 과목을 수강한 학생 sid"에 해당하는 가장 직접적인 식은?', '1', '1.Enroll ÷ Req;2.π sid ( Enroll ▷◁ Req );3.π sid ( σ cid∈Req ( Enroll ) );4.π sid ( Enroll )', 54),

    (588, 'FILL_BLANK', 'Enroll(sid, cid, grade), Student(sid, name) 스키마가 있을 때, 다음 두 식이 동치가 되도록 빈칸에 들어갈 곳을 고르시오. π name ( σ grade=''A'' ( Enroll ) ▷◁ Student ) = π name ( Student ▷◁ _____ )', '1', '1.σ grade=''A'' ( Enroll );2.π sid ( Enroll );3.σ name=''A'' ( Student );4.Enroll ÷ σ grade=''A'' ( Enroll )', 54),

    (589, 'SELECT_DESCRIPTION', 'Enroll(sid, cid), Course(cid, title) 스키마가 있을 때, "학생 sid와 수강 과목 title 쌍"을 가장 간단히 나타내는 식은?', '1', '1.π sid, title ( Enroll ▷◁ Course );2.π name, title ( Student ▷◁ Course );3.π sid, title ( Student ▷◁ Course );4.π sid, title ( σ dept=''CS'' ( Enroll ) )', 54),

    (590, 'FILL_BLANK', 'Student(sid, name, dept), Enroll(sid, cid), Course(cid, title, dept) 스키마가 있을 때, "학생이 자신의 학과(dept)의 과목을 수강한 (sid, name, title)"을 표현하시오. → π sid, name, title ( Student ▷◁ Enroll _____ Course )', '1', '1.▷◁;2.π;3.σ;4.÷', 54),

    (591, 'FILL_BLANK', 'Student(sid, name, dept), Enroll(sid, cid) 스키마가 있을 때, 다음 식에서 빈칸에 맞는 연산을 고르시오. π name ( _____ ( Student ) ▷◁ Enroll ) = "CS 학과이면서 수강 경험이 있는 학생 이름"', '1', '1.σ dept=''CS'';2.π dept;3.÷ Req;4.σ name=''CS''', 54),

    (592, 'FILL_BLANK', 'Teaches(pid, cid), Req(cid) 스키마가 있을 때, 다음 식에서 빈칸에 들어갈 가장 알맞은 표현을 고르시오. π pid ( _____ ) = "필수 과목 Req를 모두 가르친 교수 pid"', '1', '1.Teaches ÷ Req;2.π pid ( Teaches ▷◁ Req );3.σ cid IN π cid(Req) ( Teaches );4.π pid,cid ( Teaches ) ▷◁ Req', 54);

-- Unit04 - SQL 1-1 (Lesson ID: 55)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (593, 'FILL_BLANK', 'Users(id, name, status) 스키마가 있을 때, 활성 사용자 이름만 조회하려 한다. 빈칸에 들어갈 컬럼을 고르시오. \nSELECT _____ FROM Users WHERE status=''ACTIVE'';', '2', '1.id;2.name;3.*;4.id, name', 55),

    (594, 'SELECT_DESCRIPTION', 'Users(id, dept, active) 스키마가 있을 때, "CS 또는 EE 학과이면서 active=1"을 정확히 표현한 WHERE는?', '2', '1.WHERE dept=''CS'' OR dept=''EE'' AND active=1;2.WHERE (dept=''CS'' OR dept=''EE'') AND active=1;3.WHERE dept IN (''CS'',''EE'' AND active=1);4.WHERE (dept=''CS'' AND dept=''EE'') OR active=1', 55),

    (595, 'FILL_BLANK', 'Orders(id, amount) 스키마가 있을 때, 결제 금액이 100 이상 200 이하인 주문을 조회한다. 빈칸에 올바른 연산자를 고르시오. SELECT id FROM Orders WHERE amount _____ 100 AND 200;', '1', '1.BETWEEN;2.IN;3.LIKE;4.EXISTS', 55),

    (596, 'FILL_BLANK', 'Customers(id, name, phone) 스키마가 있을 때, 연락처가 없는 고객을 찾는 WHERE 조건으로 맞는 것은?', '3', '1.WHERE phone = NULL;2.WHERE phone == NULL;3.WHERE phone IS NULL;4.WHERE ISNULL(phone)', 55),

    (597, 'FILL_BLANK', 'Articles(id, title) 스키마가 있을 때, 제목이 ''SQL''로 시작하는 글을 찾는 LIKE 패턴은? SELECT id FROM Articles WHERE title LIKE _____ ;', '1', '1.''SQL%'';2.''%SQL'';3.''%SQL%'';4.''SQL_''', 55),

    (598, 'SELECT_DESCRIPTION', 'Users(u_id), Orders(o_id, user_id) 스키마가 있을 때, "주문이 없는 사용자"를 안전하게 구하는 WHERE는? (서브쿼리에 NULL이 포함될 수 있음)', '2', '1.WHERE u_id NOT IN (SELECT user_id FROM Orders);2.WHERE NOT EXISTS (SELECT 1 FROM Orders o WHERE o.user_id = u.u_id);3.WHERE u_id IN (SELECT user_id FROM Orders) = FALSE;4.WHERE user_id IS NULL', 55),

    (599, 'SELECT_DESCRIPTION', 'Users(id), Orders(id, user_id) 스키마가 있을 때, "주문이 있는 사용자만"을 가장 간결히 표현한 WHERE는?', '3', '1.WHERE id IN (SELECT user_id FROM Orders);2.WHERE EXISTS (SELECT 1 FROM Orders o WHERE o.user_id = Users.id);3.1)과 2) 모두 가능;4.WHERE id = ANY (SELECT id FROM Orders)', 55),

    (600, 'SELECT_DESCRIPTION', 'Sales(id, created_at) 스키마가 있을 때, 2025-08-01 당일 데이터만 정확히(시분초 포함) 조회하려면?', '3', '1.WHERE DATE(created_at) = ''2025-08-01'';2.WHERE created_at BETWEEN ''2025-08-01'' AND ''2025-08-01 23:59:59'';3.WHERE created_at >= ''2025-08-01'' AND created_at < ''2025-08-02'';4.WHERE created_at LIKE ''2025-08-01%''', 55),

    (601, 'SELECT_DESCRIPTION', 'Items(id, price, qty) 스키마가 있을 때, 합계(total)=price*qty가 1000 초과인 행을 고를 때 올바른 WHERE는?', '2', '1.SELECT id, price*qty AS total FROM Items WHERE total > 1000;;2.SELECT id FROM Items WHERE price*qty > 1000;;3.SELECT id FROM Items WHERE qty > 1000/price AS total;;4.SELECT id, total FROM Items WHERE price*qty > 1000;', 55),

    (602, 'FILL_BLANK', 'Employees(id, role) 스키마가 있을 때, ADMIN 또는 MANAGER만 조회하는 WHERE 절에서 빈칸에 알맞는 내용을 작성하라. WHERE role _____ (''ADMIN'', ''MANAGER'')', 'in', '-', 55),

    (603, 'SELECT_DESCRIPTION', 'Employees(id, bonus) 스키마가 있을 때, 보너스가 0보다 큰 직원만 찾는 WHERE로 ANSI 표준에 맞는 것은?', '3', '1.WHERE IFNULL(bonus,0) > 0;2.WHERE NVL(bonus,0) > 0;3.WHERE COALESCE(bonus,0) > 0;4.WHERE ISNULL(bonus,0) > 0', 55),

    (604, 'SELECT_DESCRIPTION', 'Users(id, country, status) 스키마가 있을 때, ''활성'' 사용자들의 서로 다른 ''국가'' 목록만 가져오는 올바른 SELECT는?', '2', '1.SELECT country FROM Users WHERE status=''ACTIVE'';;2.SELECT DISTINCT country FROM Users WHERE status=''ACTIVE'';;3.SELECT country FROM Users GROUP BY status=''ACTIVE'';;4.SELECT DISTINCT country FROM Users;', 55);

-- Unit04 - SQL 1-2 (Lesson ID: 56)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (605, 'SELECT_DESCRIPTION', 'Users(user_id, nickname) 스키마가 있을 때, 사용자 표시명을 닉네임이 있으면 닉네임으로, 없으면 ''user#'' || user_id로 보여주려면?', '2', '1.SELECT NVL(nickname, ''user#'' || user_id) AS display_name FROM Users;2.SELECT COALESCE(nickname, ''user#'' || user_id) AS display_name FROM Users;3.SELECT IFNULL(nickname, CONCAT(''user#'', user_id)) AS display_name FROM Users;4.SELECT CASE WHEN nickname IS NULL THEN ''user#'' || user_id END AS display_name FROM Users', 56),

    (606, 'SELECT_DESCRIPTION', 'Orders(order_id, amount, created_at) 스키마가 있을 때, ''월별'' 매출 합계를 집계하려고 한다. 올바른 GROUP BY는?', '2', '1.SELECT SUM(amount), created_at FROM Orders GROUP BY created_at;2.SELECT EXTRACT(YEAR FROM created_at) AS y, EXTRACT(MONTH FROM created_at) AS m, SUM(amount) FROM Orders GROUP BY EXTRACT(YEAR FROM created_at), EXTRACT(MONTH FROM created_at);3.SELECT TO_CHAR(created_at, ''YYYY-MM'') ym, SUM(amount) FROM Orders GROUP BY ym;4.SELECT SUM(amount) FROM Orders GROUP BY 1', 56),

    (607, 'SELECT_DESCRIPTION', 'Orders(order_id, amount, created_at) 스키마가 있을 때, 정확히 "일자별" 매출 합계를 구하는 쿼리는?', '2', '1.SELECT created_at, SUM(amount) FROM Orders GROUP BY created_at;2.SELECT CAST(created_at AS DATE) d, SUM(amount) FROM Orders GROUP BY CAST(created_at AS DATE);3.SELECT DATE(created_at) d, SUM(amount) FROM Orders GROUP BY created_at;4.SELECT SUM(amount) FROM Orders GROUP BY DATE(created_at), created_at', 56),

    (608, 'SELECT_DESCRIPTION', 'Orders(order_id, user_id) 스키마가 있을 때, COUNT(col) vs COUNT(*)의 차이로 옳은 것은?', '2', '1.COUNT(col)은 NULL 포함, COUNT(*)는 NULL 제외;2.COUNT(col)은 NULL 제외, COUNT(*)는 행 개수 전부;3.둘 다 NULL 제외;4.둘 다 NULL 포함', 56),

    (609, 'SELECT_DESCRIPTION', 'Orders(order_id, user_id, status, amount) 스키마가 있을 때, 상태가 PAID인 주문만 대상으로 사용자의 총 결제액이 1,000,000원 초과인 user_id를 찾으려면?', '2', '1.SELECT user_id FROM Orders WHERE status=''PAID'' GROUP BY user_id WHERE SUM(amount) > 1000000;2.SELECT user_id FROM Orders WHERE status=''PAID'' GROUP BY user_id HAVING SUM(amount) > 1000000;3.SELECT user_id FROM Orders GROUP BY user_id WHERE SUM(amount) > 1000000 AND status=''PAID'';4.SELECT user_id FROM Orders HAVING status=''PAID'' AND SUM(amount) > 1000000', 56),

    (610, 'FILL_BLANK', 'OrderItem(order_id, product_id, qty), Product(product_id, category) 스키마가 있을 때, 다음 쿼리의 빈칸 [A]~[C]를 알맞게 채워, 카테고리 별 판매 수량 합계를 구하고 합계가 100 이상인 카테고리만 조회하라. \nSELECT _____, SUM(oi.qty) AS total_qty \nFROM OrderItem oi JOIN Product p _____ \nGROUP BY _____ \n_____ SUM(oi.qty) >= 100;', '4', '1.A = p.category, B = HAVING, C = WHERE;2.A = HAVING, B = p.category, C = WHERE;3.A = USING(product_id), B = WHERE, C = p.category;4.A = p.category, B = USING(product_id), C = HAVING', 56),

    (611, 'FILL_BLANK', 'Orders(order_id, user_id, amount, created_at), Users(user_id, city) 스키마가 있을 때, 일자별·도시별 매출 합계를 구하려 한다. 다음 쿼리의 빈칸을 채우시오. \nSELECT CAST(o.created_at AS DATE) AS d, u.city, SUM(o.amount) AS total_amount \nFROM Orders o JOIN Users u ON u.user_id = o.user_id \nGROUP BY _____, _____ ;', '4', '1.o.created_at, u.city;2.d, u.city;3.DATE(o.created_at), Users.city;4.CAST(o.created_at AS DATE), u.city', 56),

    (612, 'SELECT_DESCRIPTION', 'Orders(order_id, user_id, status) 스키마가 있을 때, 사용자별 취소율(= 취소건수 / 전체건수)을 0~1 실수로 구하는 식으로 옳은 것은?', '2', '1.SUM(CASE WHEN status=''CANCELED'' THEN 1 END) / COUNT(*);2.SUM(CASE WHEN status=''CANCELED'' THEN 1 ELSE 0 END) * 1.0 / COUNT(*);3.COUNT(CASE WHEN status=''CANCELED'' THEN 1 END) / COUNT(*);4.AVG(CASE WHEN status=''CANCELED'' THEN 1 END)', 56),

    (613, 'SELECT_DESCRIPTION', 'Orders(order_id, user_id, created_at) 스키마가 있을 때, 월별로 구매한 서로 다른 사용자 수를 구하려면?', '2', '1.... COUNT(user_id) ... GROUP BY 년,월;2.... COUNT(DISTINCT user_id) ... GROUP BY EXTRACT(YEAR FROM created_at), EXTRACT(MONTH FROM created_at);3.... SUM(DISTINCT user_id) ...;4.... COUNT(*) FILTER (WHERE DISTINCT user_id) ...', 56),

    (614, 'SELECT_DESCRIPTION', 'Orders(order_id, created_at), OrderItem(order_id, product_id) 스키마가 있을 때, 제품별 최초 판매일과 최종 판매일을 구하는 쿼리는?', '2', '1.SELECT product_id, MIN(created_at), MAX(created_at) FROM Orders GROUP BY product_id;2.SELECT product_id, MIN(o.created_at), MAX(o.created_at) FROM OrderItem oi JOIN Orders o USING(order_id) GROUP BY product_id;3.SELECT product_id, FIRST(created_at), LAST(created_at) FROM OrderItem GROUP BY product_id;4.SELECT product_id, MIN(created_at), MAX(created_at) FROM OrderItem GROUP BY created_at', 56),

    (615, 'SELECT_DESCRIPTION', 'Orders(user_id, amount, created_at) 스키마가 있을 때, 다음 쿼리에서 표준 SQL 기준으로 잘못된 부분을 고르시오. 1. SELECT user_id, SUM(amount) AS s 2. FROM Orders 3. GROUP BY user_id 4. ORDER BY created_at', '4', '1.1;2.2;3.3;4.4', 56),

    (616, 'FILL_BLANK', 'Orders(order_id, user_id, status, amount), Users(user_id, city) 스키마가 있을 때, PAID 주문만 대상으로 도시별 평균 결제액이 50,000원 이상인 도시를 구하는 쿼리의 HAVING 부분을 완성하라. SELECT u.city, AVG(o.amount) AS avg_amt FROM Orders o JOIN Users u ON u.user_id = o.user_id WHERE o.status = ''PAID'' GROUP BY u.city HAVING _____ >= 50000;', '1', '1.AVG(o.amount);2.SUM(o.amount);3.COUNT(o.amount);4.o.amount', 56);

-- Unit04 - SQL 1-3 (Lesson ID: 57)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (617, 'SELECT_DESCRIPTION', 'Users(id, level, created_at) 스키마가 있을 때, level 내림차순, 동점이면 created_at 내림차순, 그래도 같으면 id 오름차순으로 정렬하라. 올바른 ORDER BY는?', '3', '1.ORDER BY level, created_at DESC, id;2.ORDER BY level DESC, created_at, id ASC;3.ORDER BY level DESC, created_at DESC, id ASC;4.ORDER BY level DESC, id ASC, created_at DESC', 57),

    (618, 'SELECT_DESCRIPTION', 'Posts(id, title, created_at, pinned_at) 스키마가 있을 때, 고정 글(pinned_at NOT NULL)을 먼저, 그 다음 비고정 글을, 각 그룹 내에서는 최신(created_at DESC) 순으로 정렬하라.', '2', '1.ORDER BY pinned_at DESC, created_at DESC;2.ORDER BY CASE WHEN pinned_at IS NULL THEN 1 ELSE 0 END, created_at DESC;3.ORDER BY pinned_at, created_at DESC;4.ORDER BY created_at DESC', 57),

    (619, 'FILL_BLANK', 'Posts(id, created_at) 스키마가 있을 때, 최신순으로 2페이지(page=2, size=20)를 조회하려고 한다. 빈칸을 채우시오. \nSELECT id FROM Posts \nORDER BY created_at DESC, id DESC \nLIMIT :size OFFSET _____ ;', '2', '1.:page * :size;2.(:page - 1) * :size;3.:page + :size;4.:size - :page', 57),

    (620, 'SELECT_DESCRIPTION', 'Orders(id, created_at) 스키마가 있을 때, Oracle에서 "최신 10건"을 올바르게 가져오는 쿼리는?', '2', '1.SELECT * FROM Orders WHERE ROWNUM <= 10 ORDER BY created_at DESC;2.SELECT * FROM (SELECT * FROM Orders ORDER BY created_at DESC) WHERE ROWNUM <= 10;3.SELECT * FROM Orders ORDER BY created_at DESC FETCH FIRST 10 ROWS ONLY;4.SELECT * FROM Orders WHERE ROWNUM BETWEEN 1 AND 10 ORDER BY created_at DESC', 57),

    (621, 'SELECT_DESCRIPTION', 'Posts(id, created_at, category) 스키마가 있을 때, 최신순 키셋 페이지네이션으로 "커서(created_at=:c_at, id=:c_id) 이전" 20개를 가져올 올바른 조건은?', '2', '1.WHERE created_at <= :c_at AND id < :c_id ORDER BY created_at DESC, id DESC LIMIT 20;2.WHERE (created_at, id) < (:c_at, :c_id) ORDER BY created_at DESC, id DESC LIMIT 20;3.WHERE created_at < :c_at OR id < :c_id ORDER BY created_at DESC, id DESC LIMIT 20;4.WHERE created_at < :c_at ORDER BY id DESC LIMIT 20', 57),

    (622, 'SELECT_DESCRIPTION', 'Posts(id, category, is_public, created_at) 스키마가 있을 때, 카테고리=''news'' AND is_public=TRUE 조건의 전체 행 수(페이지네이션 총 건수)를 구하는 쿼리는?', '1', '1.SELECT COUNT(*) FROM Posts WHERE category=''news'' AND is_public=TRUE;2.SELECT COUNT(*) OVER() FROM Posts WHERE category=''news'' AND is_public=TRUE LIMIT 1;3.SELECT COUNT(id) FROM Posts GROUP BY category, is_public;4.SELECT SUM(1) FROM Posts', 57),

    (623, 'SELECT_DESCRIPTION', '페이지네이션에서 신규 행 삽입으로 인한 중복/누락을 줄이는 데 더 안전한 방식은?', '2', '1.OFFSET/LIMIT;2.키셋 페이지네이션(커서 방식: WHERE (k1,k2) < (:cursor...));3.-;4.-', 57),

    (624, 'SELECT_DESCRIPTION', '1부터 시작하는 페이지 번호 p와 페이지 크기 s가 있을 때 OFFSET을 구하는 수식은?', '3', '1.p * s;2.(p - 1) + s;3.(p - 1) * s;4.p + s', 57),

    (625, 'SELECT_DESCRIPTION', 'Orders(id, user_id, amount, created_at) 스키마가 있을 때, created_at 값이 같은 행들 사이에서도 결과 정렬이 항상 결정되도록 하려면?', '2', '1.ORDER BY created_at DESC;2.ORDER BY created_at DESC, id DESC;3.ORDER BY id DESC;4.ORDER BY created_at', 57),

    (626, 'SELECT_DESCRIPTION', 'Posts(id, category, created_at) 스키마가 있을 때, WHERE category=:cat AND ORDER BY created_at DESC, id DESC 쿼리를 가속하기 좋은 인덱스는?', '2', '1.INDEX ON Posts(created_at);2.INDEX ON Posts(category, created_at DESC, id DESC);3.INDEX ON Posts(id, created_at);4.INDEX ON Posts(category)', 57),

    (627, 'SELECT_DESCRIPTION', 'Products(id, price, updated_at) 스키마가 있을 때, 가격 높은 순으로 상위 5개를 가져오는 올바른 쿼리는?', '1', '1.SELECT * FROM Products ORDER BY price DESC FETCH FIRST 5 ROWS ONLY;2.SELECT * FROM Products WHERE ROWNUM <= 5 ORDER BY price DESC;3.SELECT * FROM (SELECT * FROM Products ORDER BY price) WHERE ROWNUM <= 5;4.SELECT TOP 5 * FROM Products ORDER BY price DESC', 57),

    (628, 'FILL_BLANK', 'Posts(id, created_at) 스키마가 있을 때, 윈도우 함수로 21~40번째(페이지 2, size 20) 최신 글을 구하는 쿼리의 빈칸을 채우시오. \nSELECT id FROM \n( SELECT id, ROW_NUMBER() OVER (ORDER BY created_at DESC, id DESC) AS rn \n  FROM Posts ) t \nWHERE _____ ;', '4', '1.rn BETWEEN 20 AND 40;2.rn > 20;3.rn <= 40;4.rn >= 21 AND rn <= 40', 57);

-- Unit05 - SQL 2-1 (Lesson ID: 58)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (629, 'SELECT_DESCRIPTION', 'Departments(id, name), Employees(id, name, dept_id NULL 허용) 스키마가 있을 때, "직원이 없어도 모든 부서를 포함해 조회"하려면 어떤 조인이 적절한가?', '2', '1.INNER JOIN;2.LEFT JOIN (Departments → Employees);3.RIGHT JOIN (Employees → Departments);4.NATURAL JOIN', 58),

    (630, 'FILL_BLANK', 'Departments(id), Employees(id, dept_id) 스키마가 있을 때, "부서가 존재하는 직원만" 조회하는 빈칸을 채우시오. \nSELECT e.* \nFROM Employees e _____ JOIN Departments d \nON d.id = e.dept_id;', '1', '1.INNER;2.LEFT;3.RIGHT;4.FULL OUTER', 58),

    (631, 'SELECT_DESCRIPTION', 'NATURAL JOIN에 대한 설명으로 가장 정확한 것은?', '1', '1.동일한 이름의 모든 컬럼에 대해 자동으로 동등 조인한다.;2.기본키 컬럼만 자동으로 조인한다.;3.USING(id)와 항상 동일하다.;4.스키마 변경에 강하다.', 58),

    (632, 'FILL_BLANK', 'Employees(id, name, manager_id) 스키마가 있을 때, 직원과 그 매니저 이름을 함께 조회하되, 매니저가 없는 직원도 포함하라. \nSELECT e.name AS emp, m.name AS manager \nFROM Employees e \nLEFT JOIN Employees m \nON _____ ;', '1', '1.e.manager_id = m.id;2.e.id = m.manager_id;3.e.dept_id = m.dept_id;4.e.manager_id <> m.id', 58),

    (633, 'SELECT_DESCRIPTION', 'Departments(id), Employees(id, dept_id) 스키마가 있을 때, 다음 RIGHT JOIN을 LEFT JOIN으로 동치 변환한 것은? \nSELECT d.id, e.id \nFROM Employees e \nRIGHT JOIN Departments d \nON d.id = e.dept_id;', '1', '1.Departments d LEFT JOIN Employees e ON e.dept_id = d.id;2.Departments d INNER JOIN Employees e ON e.dept_id = d.id;3.Employees e LEFT JOIN Departments d ON d.id = e.dept_id;4.Employees e FULL OUTER JOIN Departments d ON d.id = e.dept_id', 58),

    (634, 'SELECT_DESCRIPTION', 'Customers(id), Orders(id, customer_id) 스키마가 있을 때, "주문 유무와 상관없이 모든 고객과 모든 주문을 한 번에 나열(양쪽 모두 보존)"하려면?', '4', '1.INNER JOIN;2.LEFT JOIN;3.RIGHT JOIN;4.FULL OUTER JOIN', 58),

    (635, 'FILL_BLANK', 'Customers(id), Orders(id, customer_id) 스키마가 있을 때, "주문이 없는 고객"을 의도에 가장 안전하게 구하라. 빈칸을 채우시오. SELECT c.* FROM Customers c WHERE _____ ;', '1', '1.NOT EXISTS (SELECT 1 FROM Orders o WHERE o.customer_id = c.id);2.o.id IS NULL;3.c.id NOT IN (SELECT customer_id FROM Orders);4.-', 58),

    (636, 'FILL_BLANK', 'Customers(id), Orders(id, customer_id), OrderItems(order_id, product_id) 스키마가 있을 때, "상품 :pid를 주문한 고객만(중복 없이)"을 구하라. 빈칸을 채우시오. SELECT c.* FROM Customers c WHERE _____ ;', '1', '1.EXISTS (SELECT 1 FROM Orders o JOIN OrderItems oi ON oi.order_id = o.id WHERE o.customer_id = c.id AND oi.product_id = :pid);2.c.id IN (SELECT o.customer_id FROM Orders o JOIN OrderItems oi ON oi.order_id = o.id WHERE oi.product_id = :pid);3.NATURAL JOIN으로 모두 결합 후 WHERE product_id = :pid;4.-', 58),

    (637, 'FILL_BLANK', 'Departments(id, active), Employees(id, dept_id, active) 스키마가 있을 때, "활성 부서는 모두 보이고, 활성 직원만 매칭"되도록 빈칸을 채우시오. SELECT d.id, e.id FROM Departments d LEFT JOIN Employees e ON e.dept_id = d.id _____ WHERE d.active = ''Y'';', '3', '1.AND d.active = ''Y'';2.WHERE e.active = ''Y'';3.AND e.active = ''Y'';4.-', 58),

    (638, 'FILL_BLANK', 'Posts(id), Comments(id, post_id), Likes(id, post_id) 스키마가 있을 때, "댓글 ≥1 AND 좋아요 ≥1" 포스트 개수를 중복 없이 구하라. 빈칸을 채우시오. SELECT COUNT(*) FROM Posts p WHERE _____ AND _____ ;', '2', '1.(1) p.id IN (SELECT post_id FROM Comments) (2) p.id IN (SELECT post_id FROM Likes);2.(1) EXISTS (SELECT 1 FROM Comments c WHERE c.post_id = p.id) (2) EXISTS (SELECT 1 FROM Likes l WHERE l.post_id = p.id);3.(1) JOIN Comments (2) JOIN Likes;4.-', 58),

    (639, 'FILL_BLANK', 'Users(id, name), Profiles(user_id, name, photo_url) 스키마가 있을 때, NATURAL JOIN 대신 의도 컬럼만 명시하라. 빈칸을 채우시오. SELECT * FROM Users u JOIN Profiles p ON _____ ;', '1', '1.p.user_id = u.id;2.p.name = u.name;3.USING (id);4.-', 58),

    (640, 'SELECT_DESCRIPTION', 'Employees(id, name, dept_id) 스키마가 있을 때, 같은 부서의 "동료 페어(본인은 제외)"를 구하는 조인 조건은?', '2', '1.e1.dept_id = e2.dept_id AND e1.id = e2.id;2.e1.dept_id = e2.dept_id AND e1.id <> e2.id;3.e1.dept_id <> e2.dept_id AND e1.id <> e2.id;4.e1.dept_id = e2.id', 58);

-- Unit05 - SQL 2-2 (Lesson ID: 59)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (641, 'FILL_BLANK', 'Customers(id), Orders(id, customer_id) 스키마가 있을 때, "주문이 있는 고객"만 조회. 빈칸을 채우시오. \nSELECT c.* \nFROM Customers c \nWHERE _____ ;', '1', '1.EXISTS (SELECT 1 FROM Orders o WHERE o.customer_id = c.id);2.NOT EXISTS (SELECT 1 FROM Orders o WHERE o.customer_id = c.id);3.c.id IN (SELECT o.id FROM Orders o);4.-', 59),

    (642, 'FILL_BLANK', 'Customers(id), Orders(id, customer_id) 스키마가 있을 때, 아래 IN을 JOIN으로 바꿀 때, 조인 종류를 채우시오. \nSELECT c.id FROM Customers c WHERE c.id IN (SELECT o.customer_id FROM Orders o) \n→ \nSELECT DISTINCT c.id \nFROM Customers c _____ JOIN Orders o \nON o.customer_id = c.id;', '2', '1.LEFT;2.INNER;3.RIGHT;4.FULL OUTER', 59),

    (643, 'FILL_BLANK', 'Customers(id), Orders(id, customer_id NULL 허용) 스키마가 있을 때, NULL 함정 없이 "주문이 없는 고객"을 안전하게 구하는 조건을 채우시오. \nSELECT c.* \nFROM Customers c \nWHERE _____ ;', '3', '1.c.id NOT IN (SELECT customer_id FROM Orders);2.c.id NOT IN (SELECT customer_id FROM Orders WHERE customer_id IS NOT NULL);3.NOT EXISTS (SELECT 1 FROM Orders o WHERE o.customer_id = c.id);4.-', 59),

    (644, 'SELECT_DESCRIPTION', 'IN 서브쿼리에 중복이 많아도 결과는 바뀌지 않는다.', '1', '1.참;2.거짓;3.경우에 따라 다름;4.-', 59),

    (645, 'FILL_BLANK', 'Employees(id, salary), DeptSalaries(dept_id, salary) 스키마가 있을 때, salary > ANY(SELECT salary FROM DeptSalaries WHERE dept_id = :d)와 동치인 집계 표현을 채우시오. \nsalary > _____ (SELECT salary FROM DeptSalaries WHERE dept_id = :d)', '1', '1.MIN;2.MAX;3.AVG;4.-', 59),

    (646, 'FILL_BLANK', 'Products(id, price) 스키마가 있을 때, price < ALL(SELECT price FROM Products WHERE id <> :id)와 동치인 집계 표현은? \nprice < _____ (SELECT price FROM Products WHERE id <> :id)', '1', '1.MIN;2.MAX;3.SUM;4.-', 59),

    (647, 'FILL_BLANK', 'Products(id, price), CompetitorPrices(product_id, price) 스키마가 있을 때, p.price > ANY(...)를 EXISTS로 바꿀 때 비교 연산자를 채우시오. \nSELECT p.id \nFROM Products p \nWHERE EXISTS ( \n  SELECT 1 FROM CompetitorPrices cp \n  WHERE cp.product_id = p.id AND p.price _____ cp.price \n);', '3', '1.<;2.=;3.>;4.=', 59),

    (648, 'FILL_BLANK', 'Products(id, price), CompetitorPrices(product_id, price) 스키마가 있을 때, p.price >= ALL(서브쿼리)와 동치인 NOT EXISTS 조건을 채우시오. NOT EXISTS ( SELECT 1 FROM CompetitorPrices cp WHERE cp.product_id = p.id AND p.price _____ cp.price )', '2', '1.<=;2.<;3.>;4.=', 59),

    (649, 'FILL_BLANK', 'Customers(id), Orders(id, customer_id, created_at) 스키마가 있을 때, "2025년에 주문이 없는 고객"을 LEFT JOIN으로 구한다. 빈칸을 채우시오. SELECT c.id FROM Customers c LEFT JOIN Orders o ON o.customer_id = c.id AND o.created_at >= DATE ''2025-01-01'' AND o.created_at < DATE ''2026-01-01'' WHERE _____ ;', '3', '1.o.customer_id IS NOT NULL;2.c.id IS NULL;3.o.id IS NULL;4.-', 59),

    (650, 'FILL_BLANK', 'A(a1, a2), B(b1, b2) 스키마가 있을 때, (a1, a2) IN (SELECT b1, b2 FROM B)를 EXISTS로 바꿀 때 조건을 채우시오. EXISTS (SELECT 1 FROM B b WHERE _____ )', '1', '1.b.b1 = a.a1 AND b.b2 = a.a2;2.b.b1 = a.a2 AND b.b2 = a.a1;3.b.b1 = a.a1 OR b.b2 = a.a2;4.-', 59),

    (651, 'FILL_BLANK', 'OrderItems(order_id, price) 스키마가 있을 때, oi.price > ALL(SELECT price FROM OrderItems WHERE order_id = :x)와 동치인 집계 표현은? oi.price > _____ (SELECT price FROM OrderItems WHERE order_id = :x)', '2', '1.MIN;2.MAX;3.AVG', 59),

    (652, 'FILL_BLANK', 'Customers(id), Orders(id, customer_id) 스키마가 있을 때, IN을 JOIN으로 바꿀 때, IN과 같은 "고객 중복 제거"를 위해 SELECT에 채워야 할 키워드는? SELECT _____ c.id FROM Customers c INNER JOIN Orders o ON o.customer_id = c.id;', '1', '1.DISTINCT;2.UNIQUE;3.TOP 1;4.-', 59);

-- Unit05 - SQL 2-3 (Lesson ID: 60)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (653, 'FILL_BLANK', 'A(id), B(id) 스키마가 있을 때, 두 테이블의 id를 중복 없이 합치려면 빈칸을 채우시오. \nSELECT id FROM A \n_____ \nSELECT id FROM B;', '1', '1.UNION;2.UNION ALL;3.INTERSECT;4.MINUS/EXCEPT', 60),

    (654, 'FILL_BLANK', 'A(id), B(id) 스키마가 있을 때, 두 테이블을 합칠 때 중복 허용 + 빠른 경로를 선택하라. 빈칸을 채우시오. \nSELECT id FROM A \n_____ \nSELECT id FROM B;', '2', '1.UNION;2.UNION ALL;3.INTERSECT;4.MINUS/EXCEPT', 60),

    (655, 'FILL_BLANK', 'Customers(id), Orders(customer_id) 스키마가 있을 때, 주문이 없는 고객 id를 집합 연산으로 구하라(Oracle: MINUS, PostgreSQL: EXCEPT). 빈칸을 채우시오. \nSELECT id FROM Customers \n_____ \nSELECT customer_id FROM Orders;', '4', '1.UNION;2.UNION ALL;3.INTERSECT;4.MINUS/EXCEPT', 60),

    (656, 'FILL_BLANK', 'A(id), B(id) 스키마가 있을 때, 두 테이블에 공통으로 존재하는 id만 구하라. 빈칸을 채우시오. \nSELECT id FROM A \n_____ \nSELECT id FROM B;', '3', '1.UNION;2.UNION ALL;3.INTERSECT;4.MINUS/EXCEPT', 60),

    (657, 'SELECT_DESCRIPTION', 'A(id), B(id) 스키마가 있을 때, 집합 연산 결과를 id 오름차순 정렬하려면 ORDER BY는 어디에 둬야 하는가?', '1', '1.마지막 SELECT 뒤 한 번만;2.각 SELECT마다;3.UNION ALL 사이사이;4.MINUS 앞', 60),

    (658, 'FILL_BLANK', 'A(id, active), B(id, active) 스키마가 있을 때, active=''Y'' 조건을 집합 전에 밀어 넣어 비용을 줄여라. 빈칸을 채우시오. SELECT id FROM A WHERE active=''Y'' _____ SELECT id FROM B WHERE active=''Y'';', '1', '1.UNION;2.CONCAT;3.INTERSECT;4.MINUS/EXCEPT', 60),

    (659, 'SELECT_DESCRIPTION', 'T(x 인덱스 존재), 조건: x IN (:a, :b) 스키마가 있을 때, 인덱스 활용 측면에서 유리한 형태는?', '2', '1.SELECT * FROM T WHERE x=:a OR x=:b;2.SELECT * FROM T WHERE x=:a UNION ALL SELECT * FROM T WHERE x=:b;3.SELECT * FROM T WHERE x IN (:a,:b) ORDER BY 1;4.-', 60),

    (660, 'SELECT_DESCRIPTION', 'A(id), B(id) 스키마가 있을 때, 두 테이블의 중복 포함 합계 건수를 가장 간단히 구하라.', '2', '1.SELECT COUNT(*) FROM (SELECT id FROM A UNION SELECT id FROM B);2.SELECT COUNT(*) FROM (SELECT id FROM A UNION ALL SELECT id FROM B);3.SELECT COUNT(DISTINCT id) FROM (SELECT id FROM A UNION ALL SELECT id FROM B);4.-', 60),

    (661, 'FILL_BLANK', 'A(a1,a2), B(b1,b2) 스키마가 있을 때, (a1,a2) 교집합을 구하라. 빈칸을 채우시오. SELECT a1, a2 FROM A _____ SELECT b1, b2 FROM B;', '3', '1.UNION;2.UNION ALL;3.INTERSECT;4.MINUS/EXCEPT', 60),

    (662, 'FILL_BLANK', 'A(id), B(id) 스키마가 있을 때, 두 테이블에서 중복으로 나타나는 id만 골라라(교집합 값 목록). 빈칸을 채우시오. SELECT id FROM A _____ SELECT id FROM B;', '3', '1.UNION;2.UNION ALL;3.INTERSECT;4.MINUS/EXCEPT', 60),

    (663, 'FILL_BLANK', 'A(id), B(id) 스키마가 있을 때, 다음 MINUS/EXCEPT를 NOT EXISTS로 바꿀 때 괄호 안을 채우시오. SELECT id FROM A MINUS/EXCEPT SELECT id FROM B; → SELECT a.id FROM A a WHERE NOT EXISTS (SELECT 1 FROM B b WHERE _____ );', '1', '1.b.id = a.id;2.b.id <> a.id;3.a.id IS NULL;4.-', 60),

    (664, 'SELECT_DESCRIPTION', '괄호 없이 A UNION B INTERSECT C의 평가 순서는?', '2', '1.(A UNION B) INTERSECT C;2.A UNION (B INTERSECT C);3.(A INTERSECT B) UNION C;4.-', 60);

-- Unit06 - SQL 3-1 (Lesson ID: 61)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (665, 'FILL_BLANK', 'Users 테이블 생성 시 id를 기본키로 지정하라. 빈칸을 채우시오. \nCREATE TABLE Users ( \n  id BIGINT _____ , \n  email VARCHAR(255) \n);', '1', '1.PRIMARY KEY;2.UNIQUE;3.FOREIGN KEY;4.UNION', 61),

    (666, 'FILL_BLANK', 'email을 유니크 제약으로 추가하라. 빈칸을 채우시오. \nALTER TABLE Users \nADD CONSTRAINT ux_users_email _____ (email);', '2', '1.PRIMARY KEY;2.UNIQUE;3.FOREIGN KEY;4.UNION', 61),

    (667, 'FILL_BLANK', 'Orders에 status 컬럼을 기본값 ''PENDING'', NULL 금지로 추가하라. 빈칸을 채우시오. \nALTER TABLE Orders \nADD COLUMN status VARCHAR(20) _____ ;', '4', '1.DEFAULT ''PENDING'' NULL;2.NOT NULL;3.DEFAULT ''PENDING'';4.DEFAULT ''PENDING'' NOT NULL', 61),

    (668, 'FILL_BLANK', 'Users의 nickname 컬럼을 handle로 이름 변경. 빈칸을 채우시오. \nALTER TABLE Users _____ nickname TO handle;', '1', '1.RENAME COLUMN;2.CHANGE COLUMN;3.RENAME TO;4.MODIFY', 61),

    (669, 'FILL_BLANK', 'Orders.user_id → Users(id) 외래키를 추가하며, 사용자 삭제 시 주문도 삭제되게 하라. 빈칸을 채우시오. ALTER TABLE Orders ADD CONSTRAINT fk_orders_user FOREIGN KEY (user_id) REFERENCES Users(id) ON DELETE _____ ;', '3', '1.SET NULL;2.RESTRICT;3.CASCADE;4.NO ACTION', 61),

    (670, 'FILL_BLANK', '다른 객체가 참조 중이어도 강제로 Users의 old_col 컬럼을 삭제. 빈칸을 채우시오. ALTER TABLE Users DROP COLUMN old_col _____ ;', '1', '1.CASCADE;2.RESTRICT;3.SET NULL;4.-', 61),

    (671, 'FILL_BLANK', 'Orders의 모든 행을 빠르게 지우고, 스키마는 유지하라. 빈칸을 채우시오. _____ TABLE Orders;', '1', '1.TRUNCATE;2.DROP;3.DELETE;4.-', 61),

    (672, 'FILL_BLANK', 'Users.email에 유니크 인덱스를 생성하라. 빈칸을 채우시오. CREATE _____ INDEX ux_users_email ON Users(email);', '1', '1.UNIQUE;2.PRIMARY;3.FOREIGN;4.-', 61),

    (673, 'FILL_BLANK', 'Products.price가 0보다 커야 한다. 빈칸을 채우시오. ALTER TABLE Products ADD CONSTRAINT chk_price_pos CHECK (price _____ 0);', '1', '1.>;2.>=;3.<>;4.<', 61),

    (674, 'FILL_BLANK', 'MySQL에서 Users.bio 타입을 VARCHAR(255)로 변경. 빈칸을 채우시오. ALTER TABLE Users _____ bio VARCHAR(255);', '2', '1.TYPE;2.MODIFY;3.CHANGE;4.ALTER', 61),

    (675, 'FILL_BLANK', 'OldName 테이블을 NewName으로 변경. 빈칸을 채우시오. ALTER TABLE OldName _____ NewName;', '1', '1.RENAME;2.RENAME TABLE;3.CHANGE TO;4.-', 61),

    (676, 'FILL_BLANK', 'Users 테이블이 존재할 때만 삭제. 빈칸을 채우시오. DROP TABLE _____ Users;', '3', '1.RESTRICT;2.CASCADE;3.IF EXISTS;4.NOT NULL', 61);

-- Unit06 - SQL 3-2 (Lesson ID: 62)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (677, 'FILL_BLANK', 'Users(id BIGINT PK AUTO_INCREMENT, email VARCHAR(255) NOT NULL DEFAULT ''guest@example.com'') 스키마가 있을 때, email 값을 생략하고 기본값으로 INSERT 하라. 빈칸을 채우시오. INSERT INTO Users(email) VALUES _____ ;', '1', '1.DEFAULT;2.NULL;3.'''';4.NOT NULL', 62),

    (678, 'FILL_BLANK', 'Orders(id PK, user_id BIGINT NOT NULL, FOREIGN KEY (user_id) REFERENCES Users(id)) 스키마가 있을 때, FK 위반 없이 주문을 삽입하려면 user_id에 무엇이 들어가야 하는가? 빈칸을 채우시오. INSERT INTO Orders(user_id) VALUES _____ ;', '4', '1.NOT NULL;2.NULL;3.음수;4.존재하는 Users.id', 62),

    (679, 'FILL_BLANK', 'Orders(user_id BIGINT _____ , FOREIGN KEY (user_id) REFERENCES Users(id) ON DELETE SET NULL) 스키마가 있을 때, SET NULL이 오류 없이 동작하도록 user_id 정의의 빈칸을 채우시오.', '3', '1.UNIQUE;2.NOT NULL;3.NULL;4.-', 62),

    (680, 'FILL_BLANK', 'Orders(user_id FK → Users(id) ON UPDATE CASCADE) 스키마가 있을 때, 사용자 PK가 100→200으로 바뀔 때 참조도 함께 갱신되게 하라. 빈칸을 채우시오. UPDATE Users SET id = _____ WHERE id = 100;', '1', '1.200;2.NULL;3.DEFAULT;4.NOT NULL', 62),

    (681, 'FILL_BLANK', 'Users(email UNIQUE, signups INT NOT NULL DEFAULT 0) 스키마가 있을 때, 같은 email이면 signups를 +1 하도록 UPSERT 하라. 빈칸을 채우시오. INSERT INTO Users(email, signups) VALUES(:email, 1) _____ signups = signups + 1;', '1', '1.ON DUPLICATE KEY UPDATE;2.ON CONFLICT DO UPDATE;3.REPLACE;4.-', 62),

    (682, 'FILL_BLANK', 'REPLACE는 키 충돌 시 기존 행을 _____ 한 뒤 새로 INSERT 한다.', '4', '1.SELECT;2.UPDATE;3.LOCK;4.DELETE', 62),

    (683, 'FILL_BLANK', 'Products(id PK, price DECIMAL(10,2), CHECK (price > 0)) 스키마가 있을 때, 제약을 위반하지 않게 INSERT 하라. 빈칸을 채우시오. INSERT INTO Products(price) VALUES _____ ;', '3', '1.-10;2.0;3.10;4.-10.0', 62),

    (684, 'FILL_BLANK', '대량 적재 중 FK 검사를 끄고 다시 켜라. 두 빈칸을 채우시오. SET _____ = 0; -- 적재 전 SET _____ = 1; -- 적재 후', '1', '1.FOREIGN_KEY_CHECKS;2.UNIQUE_CHECKS;3.SQL_SAFE_UPDATES;4.-', 62),

    (685, 'FILL_BLANK', 'Orders(user_id FK → Users(id) ON DELETE RESTRICT) 스키마가 있을 때, 사용자 10과 그 주문들을 삭제하라(에러 없이). 빈칸을 채우시오. DELETE FROM Orders WHERE user_id = :uid; DELETE FROM Users WHERE id = _____ ;', '1', '1.:uid;2.NULL;3.:order_id;4.-', 62),

    (686, 'FILL_BLANK', 'Users(email VARCHAR(255) NOT NULL DEFAULT ''guest@example.com'') 스키마가 있을 때, email을 기본값으로 되돌리려면? 빈칸을 채우시오. UPDATE Users SET email = _____ WHERE id = :id;', '1', '1.DEFAULT(email);2.'''';3.NULL;4.-', 62),

    (687, 'FILL_BLANK', 'Users(id BIGINT PK AUTO_INCREMENT, email UNIQUE) 스키마가 있을 때, 자동 증가 값을 사용해 삽입하라(모든 환경에서 안전). 빈칸을 채우시오. INSERT INTO Users(id, email) VALUES( _____ , ''a@b.com'');', '1', '1.DEFAULT;2.NULL;3.0;4.1', 62),

    (688, 'FILL_BLANK', 'Orders(id PK, user_id FK → Users(id)), Users(id PK, email) 스키마가 있을 때, 스팸 도메인 사용자 주문만 삭제하라. 빈칸을 채우시오. DELETE o FROM Orders o _____ Users u ON u.id = o.user_id WHERE u.email LIKE ''%@spam.com'';', '3', '1.CROSS JOIN;2.LEFT JOIN;3.INNER JOIN;4.-', 62);

-- Unit06 - SQL 3-3 (Lesson ID: 63)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (689, 'FILL_BLANK', '트랜잭션을 시작하고 변경을 확정할 때, 다음 SQL 문의 빈칸을 채우시오. \nSTART TRANSACTION; \n-- DML … \n_____ ;', '1', '1.COMMIT;2.ROLLBACK;3.SAVEPOINT sp;4.TRANSACTION', 63),

    (690, 'FILL_BLANK', '트랜잭션 내 변경을 모두 취소할 때, 다음 SQL 문의 빈칸을 채우시오. \nSTART TRANSACTION; \n-- DML … \n_____ ;', '2', '1.COMMIT;2.ROLLBACK;3.SAVEPOINT sp;4.TRANSACTION', 63),

    (691, 'FILL_BLANK', '중간 지점으로만 되돌리도록 다음 SQL 문의 빈칸을 채우시오. \nSTART TRANSACTION; \nSAVEPOINT sp1; \n-- DML A … \n_____ sp1; \n-- DML B … \nCOMMIT;', '4', '1.ROLLBACK;2.RELEASE;3.COMMIT TO;4.ROLLBACK TO', 63),

    (692, 'FILL_BLANK', '세이브포인트 sp1을 해제할 때, 다음 SQL 문의 빈칸을 채우시오. \nSTART TRANSACTION; \nSAVEPOINT sp1; \n-- DML … \n_____ SAVEPOINT sp1; \nCOMMIT;', '1', '1.RELEASE;2.ROLLBACK TO;3.DELETE;4.COMMIT TO', 63),

    (693, 'FILL_BLANK', '세션에서 자동 커밋을 끄고 수동으로 제어하려면 다음 SQL 문의 빈칸을 채우시오. _____ autocommit = 0;', '3', '1.SHOW;2.ALTER;3.SET;4.TABLE', 63),

    (694, 'FILL_BLANK', '세션 격리수준을 READ COMMITTED로 바꿀 때, 다음 SQL 문의 빈칸을 채우시오. SET SESSION TRANSACTION ISOLATION LEVEL _____ ;', '1', '1.READ COMMITTED;2.REPEATABLE READ;3.SERIALIZABLE;4.-', 63),

    (695, 'FILL_BLANK', 'InnoDB에서 일관 스냅샷을 잡아 읽기 트랜잭션을 시작할 때, 다음 SQL 문의 빈칸을 채우시오. START TRANSACTION _____ ;', '1', '1.WITH CONSISTENT SNAPSHOT;2.READ ONLY;3.FOR UPDATE;4.START TRANSACTION', 63),

    (696, 'FILL_BLANK', 'Accounts(id PK) 스키마가 있을 때, 특정 행을 업데이트 전 선점 잠금으로 읽으려면 다음 SQL 문의 빈칸을 채우시오. \nSELECT * FROM Accounts WHERE id = :id _____ ;', '3', '1.LOCK IN SHARE MODE;2.FOR SHARE;3.FOR UPDATE;4.LOCK', 63),

    (697, 'FILL_BLANK', 'Products(id PK) 스키마가 있을 때, 다른 트랜잭션의 업데이트를 막고 읽기만 허용하는 공유 잠금으로 읽으려면 다음 SQL 문의 빈칸을 채우시오. \nSELECT * FROM Products WHERE id = :id _____ ;', '2', '1.FOR UPDATE;2.FOR SHARE;3.NOWAIT;4.LOCK', 63),

    (698, 'FILL_BLANK', 'CSV를 가장 빠르게 적재하는 표준적인 구문의 빈칸을 채우시오. \n_____ DATA INFILE ''/path/file.csv'' \nINTO TABLE T \nFIELDS TERMINATED BY '','' \nENCLOSED BY ''"'' \nLINES TERMINATED BY ''\\n'' \nIGNORE 1 LINES;', '1', '1.LOAD;2.IMPORT;3.COPY;4.-', 63),

    (699, 'FILL_BLANK', 'T에 UNIQUE 키가 존재할 때, 중복키가 발생하면 해당 행을 건너뛰고 계속 적재하려면 다음 SQL 문의 빈칸을 채우시오. \nLOAD DATA INFILE ''f.csv'' \nINTO TABLE T _____ ;', '4', '1.UPDATE;2.REPLACE;3.UPSERT;4.IGNORE', 63),

    (700, 'FILL_BLANK', '자식 테이블이 FK를 보유할 때, 대량 적재 전후 FK 검사를 제어하고, 하나의 트랜잭션으로 원자적으로 처리하려면 다음 SQL 문의 빈칸을 채우시오. \nSET FOREIGN_KEY_CHECKS = 0; \nSTART TRANSACTION; \n-- LOAD DATA … \nCOMMIT; \nSET FOREIGN_KEY_CHECKS = _____ ;', '2', '1.0;2.1;3.DEFAULT;4.UNIQUE', 63);
